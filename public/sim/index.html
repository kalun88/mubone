<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>mubone — simulation (preview)</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
  }
  body {
    background: #222;
    color: #fff;
    font-family: 'Roboto Mono', monospace;
    display: flex;
    flex-direction: column;
    padding: 1rem 1.5rem;
    gap: 0.5rem;
    height: 100dvh;
    overflow: hidden;
    overscroll-behavior: none;
  }
  .main-layout {
    display: flex;
    flex-direction: row;
    gap: 1rem;
    align-items: stretch;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }
  h1 {
    font-size: 1rem;
    font-weight: normal;
    color: #aaa;
    letter-spacing: 0.05em;
    border-bottom: 1px solid #555;
    padding-bottom: 0.4rem;
    flex-shrink: 0;
    width: 100%;
  }
  .canvas-wrapper {
    position: relative;
    flex: 1;
    min-width: 0;
    min-height: 0;
    background: #1a2a2a;
    border: 1px solid #555;
    border-radius: 4px;
    overflow: hidden;
    cursor: none;
  }
  .canvas-wrapper:fullscreen,
  .canvas-wrapper:-webkit-full-screen {
    width: 100vw;
    height: 100vh;
    aspect-ratio: unset;
    border: none;
    border-radius: 0;
  }
  body:has(.canvas-wrapper:fullscreen) > *:not(.canvas-wrapper),
  body:has(.canvas-wrapper:-webkit-full-screen) > *:not(.canvas-wrapper) {
    display: none !important;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    cursor: none;
  }
  .hud {
    position: absolute;
    top: 1rem;
    left: 1rem;
    font-size: 0.75rem;
    color: #aaa;
    pointer-events: none;
    display: flex;
    gap: 1.5rem;
  }
  #paintIndicator {
    color: #555;
    transition: color 0.15s;
  }
  #paintIndicator.active {
    color: #fff;
  }
  /* ── Bottom-of-canvas status bar ─────────────────────────────────────────── */
  .canvas-bottom-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    align-items: center;
    gap: 1.2rem;
    padding: 0.4rem 0.75rem;
    font-size: 0.65rem;
    color: #555;
    pointer-events: none;
  }
  #liveRecStatus {
    color: #555;
  }
  #liveRecStatus.recording {
    color: #e06060;
  }
  #liveRecStatus .rec-dot {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #e06060;
    margin-right: 4px;
    animation: rec-pulse 1s ease-in-out infinite;
  }
  @keyframes rec-pulse {
    0%, 100% { opacity: 1; }
    50%       { opacity: 0.3; }
  }
  .instructions {
    font-size: 0.7rem;
    color: #555;
    letter-spacing: 0.05em;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.3rem 0.5rem;
    flex-shrink: 0;
  }
  .instructions .sep {
    color: #333;
  }
  .key {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: #2a2a2a;
    border: 1px solid #444;
    border-bottom-width: 2px;
    border-radius: 4px;
    color: #888;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.65rem;
    padding: 0.1rem 0.4rem;
    white-space: nowrap;
    line-height: 1.4;
  }
  /* ── Bottom output meter bar ─────────────────────────────────────────────── */
  .output-meter-bar {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    width: 100%;
    padding: 0.15rem 0;
    flex-shrink: 0;
  }
  .output-meter-bar .meter-label {
    font-size: 0.6rem;
    color: #444;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .output-meter-bar .meter-wrap {
    flex: 1;
    height: 6px;
    background: #1c2a2a;
    border-radius: 2px;
    overflow: hidden;
    position: relative;
  }
  #outputMeterCanvasBottom {
    display: block;
    width: 100%;
    height: 100%;
  }
  .output-meter-bar .meter-clip-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #333;
    flex-shrink: 0;
    transition: background 0.05s, box-shadow 0.05s;
  }
  .output-meter-bar .meter-clip-dot.clipping {
    background: #e06060;
    box-shadow: 0 0 5px #e06060;
  }
  /* ── Drop zone overlay ───────────────────────────────────────────────────── */
  .drop-overlay {
    position: absolute;
    inset: 0;
    background: rgba(26, 42, 42, 0.92);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
  }
  .drop-overlay.visible { opacity: 1; }
  .drop-overlay .drop-icon { font-size: 2rem; color: #7abcbc; }
  .drop-overlay .drop-text { font-size: 0.85rem; color: #aaa; letter-spacing: 0.05em; }

  /* ── Right sidebar panel ─────────────────────────────────────────────────── */
  .bottom-panel {
    width: 240px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    align-items: stretch;
    overflow: hidden;
    align-self: stretch;
    justify-content: space-between;
    min-height: 0;
  }

  /* ── Loaded sample list (left column) ───────────────────────────────────── */
  .sample-list-panel {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .sample-list-panel--full {
    width: 100%;
    flex-shrink: 0;
  }
  .sample-list-panel--full .sample-list {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2px;
  }
  .sample-list-panel--full .slot-name {
    max-width: 100px;
  }
  .sample-list-panel .panel-label {
    color: #444;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    border-bottom: 1px solid #333;
    padding-bottom: 0.25rem;
    margin-bottom: 0.1rem;
  }
  .sample-list {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  .sample-slot {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.3rem 0.25rem 0.3rem 0;
    font-size: 0.7rem;
    color: #555;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 3px;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
    user-select: none;
    min-height: 28px;
  }
  .sample-slot:hover { background: #2a3a3a; }
  .sample-slot.active {
    border-color: #7abcbc;
    background: #2a3a3a;
  }
  /* "active" here means the key is toggled ON for painting */
  .sample-slot.painting {
    border-color: var(--slot-color, #7abcbc);
    background: #2a3a3a;
  }
  .sample-slot.loaded { color: #aaa; }
  .sample-slot.empty.active { border-color: #555; }
  .sample-slot.drag-over { border-color: #7abcbc; background: #2a3a3a; }
  .sample-slot .slot-drag-handle {
    color: #444;
    cursor: grab;
    font-size: 0.8rem;
    line-height: 1;
    padding: 0 2px;
    visibility: hidden;
  }
  .sample-slot.loaded .slot-drag-handle { visibility: visible; }
  .sample-slot.loaded .slot-drag-handle:hover { color: #888; }
  .sample-slot .slot-key {
    color: #555;
    width: 1em;
    flex-shrink: 0;
    text-align: left;
  }
  /* Key shows the sample colour when that slot is actively painting */
  .sample-slot.painting .slot-key { color: var(--slot-color, #7abcbc); }
  .sample-slot .slot-name {
    color: #aaa;
    flex-shrink: 0;
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .sample-slot.empty .slot-name { color: #444; }
  .sample-slot .slot-duration { color: #666; flex-shrink: 0; }
  .sample-slot .slot-waveform {
    flex: 1;
    height: 18px;
    background: #303030;
    border-radius: 2px;
    overflow: hidden;
    position: relative;
    min-width: 60px;
  }
  .sample-slot.loaded .slot-waveform { height: 28px; cursor: default; }
  .sample-slot.loaded .slot-waveform.near-handle { cursor: col-resize; }
  .sample-slot .slot-waveform canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0; left: 0;
    pointer-events: none; /* let mouse events fall through to waveDiv */
  }
  .sample-slot.empty .slot-waveform { background: #282828; opacity: 0.4; }
  .sample-slot .slot-play {
    color: #555;
    font-size: 0.75rem;
    line-height: 1;
    padding: 0 2px;
    cursor: pointer;
    visibility: hidden;
    border: none;
    background: none;
    font-family: inherit;
    flex-shrink: 0;
  }
  .sample-slot.loaded .slot-play { visibility: visible; }
  .sample-slot.loaded .slot-play:hover { color: #7abcbc; }
  .sample-slot.loaded .slot-play.playing { color: #e0c860; }
  .sample-slot .slot-delete {
    color: #555;
    font-size: 0.85rem;
    line-height: 1;
    padding: 0 4px;
    cursor: pointer;
    visibility: hidden;
    border: none;
    background: none;
    font-family: inherit;
  }
  .sample-slot.loaded .slot-delete { visibility: visible; }
  .sample-slot.loaded .slot-delete:hover { color: #e06060; }

  /* ── Grain presets panel ─────────────────────────────────────────────────── */
  .preset-panel {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .preset-panel .panel-label {
    color: #444;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    border-bottom: 1px solid #333;
    padding-bottom: 0.25rem;
    margin-bottom: 0.1rem;
  }
  .preset-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 3px;
  }
  .preset-btn {
    background: transparent;
    border: 1px solid #444;
    color: #666;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.65rem;
    padding: 0.25rem 0.3rem;
    border-radius: 3px;
    cursor: pointer;
    transition: border-color 0.15s, color 0.15s;
    letter-spacing: 0.03em;
  }
  .preset-btn:hover {
    border-color: #7abcbc;
    color: #aaa;
  }
  .preset-btn.active {
    border-color: #7abcbc;
    color: #7abcbc;
  }
  .preset-waveform-wrap {
    position: relative;
    width: 100%;
    height: 48px;
    background: #1c2a2a;
    border-radius: 3px;
    overflow: hidden;
  }
  #presetWaveform {
    display: block;
    width: 100%;
    height: 100%;
  }
  .preset-stats {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 0.1rem 0.5rem;
    font-size: 0.6rem;
    color: #555;
  }
  .preset-stats .stat-label { color: #555; white-space: nowrap; }
  .preset-stats span { color: #7abcbc; }
  .recency-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 0.6rem;
    color: #555;
    margin-top: 0.3rem;
  }
  .recency-ctrl {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }
  .recency-ctrl span { color: #7abcbc; min-width: 1rem; text-align: center; }
  .recency-btn {
    background: #2a2a2a;
    border: 1px solid #444;
    border-bottom-width: 2px;
    border-radius: 3px;
    color: #777;
    font-size: 0.65rem;
    line-height: 1;
    padding: 0.1rem 0.35rem;
    cursor: pointer;
  }
  .recency-btn:hover { color: #fff; border-color: #666; }

  /* ── Cloud banks panel ───────────────────────────────────────────────────── */
  .cloud-panel {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
  }
  .cloud-slots {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 3px;
  }
  .cloud-slot {
    aspect-ratio: 1;
    border-radius: 3px;
    border: 1px solid #333;
    font-size: 0.55rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.2s, box-shadow 0.2s;
  }
  .cloud-slot--empty { color: #333; background: transparent; }
  .cloud-slot--active { }
  .cloud-slot--nearest {
    box-shadow: 0 0 6px currentColor;
    border-width: 2px;
  }

  /* ── Playback controls panel ─────────────────────────────────────────────── */
  .playback-panel {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .playback-panel .panel-label {
    color: #444;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    border-bottom: 1px solid #333;
    padding-bottom: 0.25rem;
    margin-bottom: 0.1rem;
  }
  #snapToggleBtn {
    background: transparent;
    border: 1px solid #444;
    color: #666;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.7rem;
    padding: 0.3rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    letter-spacing: 0.03em;
    transition: border-color 0.15s, color 0.15s, box-shadow 0.15s;
    width: 100%;
    text-align: left;
  }
  #snapToggleBtn:hover {
    border-color: #e8a030;
    color: #aaa;
  }
  #snapToggleBtn.active {
    border-color: #e8a030;
    color: #e8a030;
    box-shadow: 0 0 6px #e8a03044;
  }
  .radius-viz-wrap {
    position: relative;
    width: 100%;
    height: 60px;
    background: #1c2a2a;
    border-radius: 3px;
    overflow: hidden;
  }
  #radiusViz {
    display: block;
    width: 100%;
    height: 100%;
  }
  /* ── Output level meter ─────────────────────────────────────────────────── */
  .meter-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }
  .meter-label {
    font-size: 0.6rem;
    color: #444;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .meter-wrap {
    flex: 1;
    height: 8px;
    background: #1c2a2a;
    border-radius: 2px;
    overflow: hidden;
    position: relative;
  }
  #outputMeterCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  .meter-clip-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #444;
    flex-shrink: 0;
    transition: background 0.05s, box-shadow 0.05s;
  }
  .meter-clip-dot.clipping {
    background: #e06060;
    box-shadow: 0 0 5px #e06060;
  }

  /* ── Fullscreen button ───────────────────────────────────────────────────── */
  #fullscreenBtn {
    position: absolute;
    bottom: 0.75rem;
    right: 0.75rem;
    background: rgba(34,34,34,0.7);
    border: 1px solid #666;
    color: #ccc;
    font-family: 'Roboto Mono', monospace;
    font-size: 1rem;
    padding: 0.4rem 0.6rem;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.7;
    transition: opacity 0.2s, border-color 0.2s, color 0.2s;
    z-index: 10;
    line-height: 1;
  }
  #fullscreenBtn:hover {
    opacity: 1;
    border-color: #aaa;
    color: #fff;
  }

  /* ── Live rec panel (right column) ──────────────────────────────────────── */
  .live-rec-panel {
    font-size: 0.7rem;
    color: #555;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }
  .live-rec-panel .panel-label {
    color: #444;
    letter-spacing: 0.05em;
    border-bottom: 1px solid #333;
    padding-bottom: 0.25rem;
    margin-bottom: 0.1rem;
  }
  .live-rec-panel .live-count {
    color: #aaa;
  }
  .live-rec-panel .live-count span {
    color: #e8a030;
  }
  .live-rec-panel .undo-hint {
    color: #444;
    font-size: 0.65rem;
  }
  #micEnableBtn.mic-ready  { color: #7abcbc; border-color: #7abcbc; cursor: default; }
  #micEnableBtn.mic-denied { color: #e06060; border-color: #e06060; cursor: default; }
  .live-rec-panel .live-granulating {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    color: #444;
    font-size: 0.65rem;
    transition: color 0.1s;
  }
  .live-rec-panel .live-granulating.active {
    color: #e8a030;
  }
  .live-rec-panel .live-granulating .gran-dot {
    display: inline-block;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: #444;
    transition: background 0.1s, box-shadow 0.1s;
    flex-shrink: 0;
  }
  .live-rec-panel .live-granulating.active .gran-dot {
    background: #e8a030;
    box-shadow: 0 0 6px #e8a030;
  }
  /* ── Input gain knob + input meter ────────────────────────────────────── */
  .input-gain-knob-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.4rem;
  }
  .knob-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.15rem;
    flex-shrink: 0;
  }
  #inputGainKnob {
    display: block;
    cursor: ns-resize; /* drag up/down — standard DAW convention */
    touch-action: none;
  }
  .knob-label {
    font-size: 0.58rem;
    color: #555;
    letter-spacing: 0.03em;
  }
  .knob-val {
    font-size: 0.58rem;
    color: #7abcbc;
    min-width: 2.8rem;
    text-align: left;
  }
  .input-meter-row {
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }
  .input-meter-label {
    font-size: 0.6rem;
    color: #444;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .input-meter-wrap {
    flex: 1;
    height: 4px;
    background: #1c2a2a;
    border-radius: 2px;
    overflow: hidden;
  }
  #inputMeterCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  .input-clip-dot {
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: #333;
    flex-shrink: 0;
    transition: background 0.05s, box-shadow 0.05s;
  }
  .input-clip-dot.clipping {
    background: #e06060;
    box-shadow: 0 0 5px #e06060;
  }

  /* ── MIDI / Keyboard mapping modal ──────────────────────────────────────── */
  #mappingModal {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0,0,0,0.75);
    align-items: center;
    justify-content: center;
  }
  #mappingModal.open { display: flex; }
  .mapping-dialog {
    background: #1e1e1e;
    border: 1px solid #444;
    border-radius: 6px;
    padding: 1.2rem;
    width: min(700px, 92vw);
    max-height: 85vh;
    overflow-y: auto;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.72rem;
    color: #aaa;
  }
  .mapping-dialog h2 {
    font-size: 0.85rem;
    color: #fff;
    margin: 0 0 0.8rem 0;
    letter-spacing: 0.06em;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .mapping-dialog h2 .close-btn {
    background: none;
    border: none;
    color: #666;
    font-size: 1rem;
    cursor: pointer;
    padding: 0;
  }
  .mapping-dialog h2 .close-btn:hover { color: #fff; }
  .mapping-status {
    font-size: 0.65rem;
    color: #e8a030;
    min-height: 1.2rem;
    margin-bottom: 0.5rem;
  }
  .mapping-table {
    width: 100%;
    border-collapse: collapse;
  }
  .mapping-table th {
    color: #555;
    font-weight: normal;
    text-align: left;
    padding: 0.2rem 0.4rem;
    border-bottom: 1px solid #333;
    font-size: 0.6rem;
    letter-spacing: 0.05em;
  }
  .mapping-table td {
    padding: 0.25rem 0.4rem;
    border-bottom: 1px solid #2a2a2a;
    vertical-align: middle;
  }
  .mapping-table tr:hover td { background: #252525; }
  .mapping-table .fn-name { color: #ddd; }
  .mapping-table .key-badge {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    background: #2a2a2a;
    border: 1px solid #444;
    border-bottom-width: 2px;
    border-radius: 3px;
    color: #888;
    font-size: 0.6rem;
    padding: 0.05rem 0.3rem;
  }
  .mapping-table .midi-cell { color: #7abcbc; }
  .mapping-table .midi-cell.unassigned { color: #444; font-style: italic; }
  .learn-btn {
    background: #2a2a2a;
    border: 1px solid #444;
    border-radius: 3px;
    color: #666;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.6rem;
    padding: 0.15rem 0.4rem;
    cursor: pointer;
    white-space: nowrap;
  }
  .learn-btn:hover { color: #fff; border-color: #666; }
  .learn-btn.learning {
    border-color: #e8a030;
    color: #e8a030;
    animation: learnPulse 0.8s infinite alternate;
  }
  @keyframes learnPulse { from { opacity: 1; } to { opacity: 0.4; } }
  .clear-midi-btn {
    background: none;
    border: none;
    color: #444;
    font-size: 0.7rem;
    cursor: pointer;
    padding: 0 0.2rem;
  }
  .clear-midi-btn:hover { color: #e06060; }
  .mapping-footer {
    margin-top: 0.8rem;
    font-size: 0.6rem;
    color: #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .mapping-footer button {
    background: none;
    border: 1px solid #444;
    border-radius: 3px;
    color: #666;
    font-family: 'Roboto Mono', monospace;
    font-size: 0.6rem;
    padding: 0.2rem 0.6rem;
    cursor: pointer;
  }
  .mapping-footer button:hover { color: #fff; border-color: #666; }
</style>
</head>
<body>
  <h1>simulation</h1>
  <div class="main-layout">
  <div class="canvas-wrapper" id="canvasWrapper">
    <canvas id="sphereCanvas"></canvas>
    <div class="hud">
      <div id="coordinates">--,--</div>
      <div id="paintIndicator">paint: off</div>
      <div id="sampleIndicator" style="color:#555">no sample</div>
      <div id="radiusIndicator" style="color:#7abcbc">r: 10°</div>
    </div>
    <!-- Live recording status inside canvas (bottom bar) -->
    <div class="canvas-bottom-bar">
      <div id="liveRecStatus">space: rec+paint</div>
    </div>
    <!-- Performance monitor overlay (toggle with P) -->
    <div id="perfMonitor" style="display:none;position:absolute;top:2.5rem;left:1rem;font-family:'Roboto Mono',monospace;font-size:0.6rem;color:#aaa;pointer-events:none;line-height:1.7;background:rgba(0,0,0,0.55);padding:0.35rem 0.5rem;border-radius:3px;"></div>
    <button id="fullscreenBtn" title="fullscreen">⛶</button>
    <div class="drop-overlay" id="dropOverlay">
      <div class="drop-icon">↓</div>
      <div class="drop-text">drop audio file (.wav, .mp3, .ogg)</div>
    </div>
  </div>

  <!-- Right sidebar: signal path order — live rec → input → samples → grain → playback -->
  <div class="bottom-panel">

    <!-- 1. Live rec -->
    <div class="live-rec-panel">
      <div class="panel-label">live rec</div>
      <button id="micEnableBtn">enable mic</button>
      <div class="live-count" id="liveRecCount">buffers: <span>0</span></div>
      <div class="live-granulating" id="liveGranulating">
        <span class="gran-dot"></span>granulating
      </div>
      <div class="undo-hint">⌘Z / ctrl+Z — undo last stroke</div>
    </div>

    <!-- 2. Input gain + level meter -->
    <div class="playback-panel">
      <div class="panel-label">input</div>
      <div class="input-gain-knob-row">
        <div class="knob-wrap">
          <canvas id="inputGainKnob" width="36" height="36"></canvas>
          <span class="knob-label">in gain</span>
        </div>
        <span class="knob-val" id="inputGainVal">1.00×</span>
      </div>
      <div class="input-meter-row">
        <span class="input-meter-label">in</span>
        <div class="input-meter-wrap">
          <canvas id="inputMeterCanvas"></canvas>
        </div>
        <div class="input-clip-dot" id="inputClipDot"></div>
      </div>
    </div>

    <!-- 4. Grain preset -->
    <div class="preset-panel">
      <div class="panel-label">grain preset</div>
      <div class="preset-buttons" id="presetButtons"></div>
      <div class="preset-waveform-wrap">
        <canvas id="presetWaveform"></canvas>
      </div>
      <div class="preset-stats">
        <span class="stat-label">dur</span><span id="psDur">—</span>
        <span class="stat-label">k</span><span id="psK">—</span>
        <span class="stat-label">pan</span><span id="psPan">—</span>
      </div>
      <div class="recency-row">
        <span class="stat-label">recency</span>
        <div class="recency-ctrl">
          <button class="recency-btn" id="recencyDec">−</button>
          <span id="recencyVal">3</span>
          <button class="recency-btn" id="recencyInc">+</button>
        </div>
      </div>
    </div>

    <!-- 5. Cloud banks -->
    <div class="cloud-panel">
      <div class="panel-label">clouds</div>
      <div class="cloud-slots" id="cloudSlots">
        <div class="cloud-slot cloud-slot--empty">1</div>
        <div class="cloud-slot cloud-slot--empty">2</div>
        <div class="cloud-slot cloud-slot--empty">3</div>
        <div class="cloud-slot cloud-slot--empty">4</div>
        <div class="cloud-slot cloud-slot--empty">5</div>
        <div class="cloud-slot cloud-slot--empty">6</div>
        <div class="cloud-slot cloud-slot--empty">7</div>
        <div class="cloud-slot cloud-slot--empty">8</div>
      </div>
    </div>

    <!-- 6. Playback (output) -->
    <div class="playback-panel">
      <div class="panel-label">playback</div>
      <button id="snapToggleBtn">snap: off</button>
      <div class="radius-viz-wrap">
        <canvas id="radiusViz"></canvas>
      </div>
      <div class="meter-row">
        <span class="meter-label">out</span>
        <div class="meter-wrap">
          <canvas id="outputMeterCanvas"></canvas>
        </div>
        <div class="meter-clip-dot" id="meterClipDot"></div>
      </div>
    </div>

  </div>
  </div><!-- end .main-layout -->

  <!-- Loaded samples — full width below sphere -->
  <div class="sample-list-panel sample-list-panel--full">
    <div class="panel-label">loaded samples</div>
    <div class="sample-list" id="sampleList"></div>
  </div>

  <div class="instructions">
    <span class="key">mouse</span> rotate
    <span class="sep">·</span>
    <span class="key">click</span> / <span class="key">space</span> rec+paint
    <span class="sep">·</span>
    <span class="key">1–9</span> paint sample
    <span class="sep">·</span>
    <span class="key">scroll</span> / <span class="key">[ ]</span> radius
    <span class="sep">·</span>
    <span class="key">right click</span> / <span class="key">⌘Z</span> undo
    <span class="sep">·</span>
    <span class="key">↓</span> drop cloud
    <span class="sep">·</span>
    <span class="key">↑</span> pick up cloud
    <span class="sep">·</span>
    <span class="key">N</span> snap
    <span class="sep">·</span>
    <span class="key">M</span> midi map
    <span class="sep">·</span>
    <span class="key">P</span> perf
  </div>

  <div class="output-meter-bar">
    <span class="meter-label">out</span>
    <div class="meter-wrap">
      <canvas id="outputMeterCanvasBottom"></canvas>
    </div>
    <div class="meter-clip-dot" id="meterClipDotBottom"></div>
  </div>

<!-- ── MIDI / Keyboard mapping modal ──────────────────────────────────────── -->
<div id="mappingModal">
  <div class="mapping-dialog">
    <h2>
      midi + keyboard map
      <button class="close-btn" id="mappingClose">✕</button>
    </h2>
    <div class="mapping-status" id="mappingStatus"></div>
    <table class="mapping-table">
      <thead>
        <tr>
          <th>function</th>
          <th>keyboard</th>
          <th>midi</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="mappingTableBody"></tbody>
    </table>
    <div class="mapping-footer">
      <span>midi in: <span id="midiPortName">—</span></span>
      <button id="clearAllMidi">clear all midi</button>
    </div>
  </div>
</div>

<script>
// ============================================================================
// CONSTANTS
// ============================================================================

const SPHERE_RADIUS       = 1200;
const GRID_SEGMENTS_LON   = 36;  // every 10°
const GRID_SEGMENTS_LAT   = 18;  // every 10°
const AUTO_ROTATION_SPEED = 0.0001;
const ROTATION_SPEED      = 0.06;
const FOV_DEG             = 80;
const PAINT_INTERVAL      = 3;
const PARTICLE_BASE_SIZE  = 4;
const PARTICLE_MAX_SIZE   = 20;
const MAX_SAMPLES         = 9;

const SEARCH_RADIUS_MIN  = 1;
const SEARCH_RADIUS_MAX  = 180;
const SEARCH_RADIUS_STEP = 2;

const BG_COLOR   = '#1a2a2a';
const GRID_COLOR = '#7abcbc';

// ── Hann window curves (precomputed Float32Arrays for setValueCurveAtTime) ──
// Web Audio requires at least 2 samples; we use 128 for smoothness.
// HANN_ATTACK : 0 → 1 over the attack portion  (first half of Hann: cos rising)
// HANN_RELEASE: 1 → 0 over the release portion (second half of Hann: cos falling)
const HANN_LEN = 128;
const HANN_ATTACK  = new Float32Array(HANN_LEN);
const HANN_RELEASE = new Float32Array(HANN_LEN);
for (let i = 0; i < HANN_LEN; i++) {
  // Attack: 0.5*(1 - cos(π * i/(N-1)))  — rises from 0 to 1
  HANN_ATTACK[i]  = 0.5 * (1 - Math.cos(Math.PI * i / (HANN_LEN - 1)));
  // Release: 0.5*(1 + cos(π * i/(N-1))) — falls from 1 to 0
  HANN_RELEASE[i] = 0.5 * (1 + Math.cos(Math.PI * i / (HANN_LEN - 1)));
}

// Scaled Hann curves reused every grain — rebuilt once on preset change.
// Avoids allocating two Float32Array(128) per grain (thousands of GC objects/sec).
let GRAIN_ATTACK_CURVE  = new Float32Array(HANN_LEN);
let GRAIN_RELEASE_CURVE = new Float32Array(HANN_LEN);
function rebuildHannCurves(volume) {
  for (let i = 0; i < HANN_LEN; i++) {
    GRAIN_ATTACK_CURVE[i]  = HANN_ATTACK[i]  * volume;
    GRAIN_RELEASE_CURVE[i] = HANN_RELEASE[i] * volume;
  }
}

// Loaded-sample paint colours (cooler, more saturated)
const SAMPLE_PAINT_COLORS = [
  '#ff6b6b', '#ffa06b', '#ffd06b',
  '#a0ff6b', '#6bffa0', '#6bffd0',
  '#6ba0ff', '#6b6bff', '#d06bff'
];

// Live-rec paint colours (warm amber/orange/gold family)
const LIVE_PAINT_COLORS = [
  '#e8a030', '#e86030', '#e8c840',
  '#c87830', '#e07050', '#d4a060',
  '#c8603a', '#e8b050', '#d06838'
];

// ── Grain presets ─────────────────────────────────────────────────────────
// k = max particles selected per frame (MuBu-style k-nearest cap).
// Without this, a large brush radius selects many particles and all fire
// simultaneously → everything sounds washed regardless of other params.
const PRESETS = [
  {
    name:         'default',
    // medium grains, moderate k — clear individual grains
    k:            5,
    duration:     0.18,   // 180ms
    durJitter:    0.06,
    overlap:      0.04,
    fade:         0.04,
    retriggerMs:  120,
    startJitter:  0.06,
    sprayCount:   2,
    spraySpread:  0.03,
    pitchJitter:  0,
    panSpread:    0.6,
    volume:       0.06,   // k=5, spray=2 → up to 10 voices × 0.06 = 0.6 sum
  },
  {
    name:         'cloud',
    // long grains, high k, lots of overlap → thick, washy texture (Mutable Instruments Clouds)
    k:            24,
    duration:     0.8,    // 800ms
    durJitter:    0.3,
    overlap:      0.5,
    fade:         0.22,
    retriggerMs:  50,
    startJitter:  0.25,
    sprayCount:   4,
    spraySpread:  0.15,
    pitchJitter:  0.02,
    panSpread:    1.0,
    volume:       0.006,  // k=24, spray=4 → up to 96 voices × 0.006 = 0.58 sum
  },
  {
    name:         'crackle',
    // very short grains, low k, sparse → stuttery individual snaps (Afterneath-inspired)
    k:            2,
    duration:     0.025,  // 25ms
    durJitter:    0.01,
    overlap:      0.002,
    fade:         0.005,
    retriggerMs:  35,
    startJitter:  0.3,
    sprayCount:   1,
    spraySpread:  0.008,
    pitchJitter:  0.08,
    panSpread:    0.25,
    volume:       0.25,   // k=2, spray=1 → up to 2 voices × 0.25 = 0.5 sum
  },
  {
    name:         'tape',
    // slow, sluggish playback position, pitch-warped, slight wow/flutter (Red Panda Tensor)
    k:            6,
    duration:     0.55,   // 550ms — long enough to feel sluggish
    durJitter:    0.18,
    overlap:      0.3,
    fade:         0.18,
    retriggerMs:  80,
    startJitter:  0.02,   // very small jitter — stays near same tape position
    sprayCount:   2,
    spraySpread:  0.04,
    pitchJitter:  0.04,   // flutter
    panSpread:    0.35,
    volume:       0.05,   // k=6, spray=2 → up to 12 voices × 0.05 = 0.6 sum
  },
  {
    name:         'scatter',
    // random sparse bursts across wide area, unpredictable (Hologram Microcosm)
    k:            8,
    duration:     0.12,   // 120ms — snappy but not tiny
    durJitter:    0.08,
    overlap:      0.01,
    fade:         0.02,
    retriggerMs:  200,    // slow retrigger → sparse bursts
    startJitter:  0.45,   // wide random position scatter
    sprayCount:   3,
    spraySpread:  0.25,   // wide spray spread
    pitchJitter:  0.12,   // noticeable pitch scatter
    panSpread:    1.0,
    volume:       0.07,   // k=8, spray=3 → up to 24 voices × 0.07 = 1.68 → keep sparse
  },
  {
    name:         'freeze',
    // extremely long overlapping grains, stays glued to one position → frozen sustain (Strymon Cloudburst)
    k:            30,
    duration:     2.0,    // 2s — very long
    durJitter:    0.4,
    overlap:      0.8,    // heavy overlap → permanent wash
    fade:         0.5,
    retriggerMs:  30,
    startJitter:  0.005,  // almost zero — freezes on same region
    sprayCount:   5,
    spraySpread:  0.05,
    pitchJitter:  0.005,
    panSpread:    0.9,
    volume:       0.003,  // k=30, spray=5 → up to 150 voices × 0.003 = 0.45 sum
  },
  {
    name:         'shimmer',
    // pitch-shifted upward texture with high overlap → ethereal shimmer (Mutable Instruments Beads)
    k:            16,
    duration:     0.45,   // 450ms
    durJitter:    0.15,
    overlap:      0.45,
    fade:         0.15,
    retriggerMs:  40,
    startJitter:  0.12,
    sprayCount:   3,
    spraySpread:  0.1,
    pitchJitter:  0.18,   // higher pitch jitter → shimmery octave-ish spread
    panSpread:    0.85,
    volume:       0.008,  // k=16, spray=3 → up to 48 voices × 0.008 = 0.38 sum
  },
  {
    name:         'gravel',
    // dense, gritty, medium-short grains — lots of voices, rough texture (Empress Zoia granular)
    k:            12,
    duration:     0.065,  // 65ms — short but not micro
    durJitter:    0.04,
    overlap:      0.15,
    fade:         0.015,
    retriggerMs:  25,     // fast retrigger → dense
    startJitter:  0.2,
    sprayCount:   4,
    spraySpread:  0.07,
    pitchJitter:  0.06,
    panSpread:    0.7,
    volume:       0.012,  // k=12, spray=4 → up to 48 voices × 0.012 = 0.58 sum
  },
];

// Active grain params — updated when a preset is selected
let grainParams = { ...PRESETS[0] };
let activePresetIndex = 0;
rebuildHannCurves(grainParams.volume); // init scaled curves for default preset

// Shorthand aliases (used throughout playback code)
const gp = () => grainParams;

// ============================================================================
// STATE
// ============================================================================

let canvas, ctx;
let camQ = [1, 0, 0, 0];       // camera orientation quaternion
let mouseX = 0, mouseY = 0;
let mousePixelX = 0, mousePixelY = 0;
let mouseInCanvas = false;
let searchRadiusDeg = 10;
let nearestMode = false;   // when true: ignore radius, always pick closest particle

// ── Painting ─────────────────────────────────────────────────────────────────
let isPainting = false;          // true while mouse-move painting is active
let paintFrameCount = 0;
let particles = [];              // all painted particles on the sphere

// ── Stroke history (for undo) ─────────────────────────────────────────────
// Each entry: { strokeId, type: 'sample'|'live', liveBufferIndex (live only) }
let strokeHistory = [];
let strokeIdCounter = 0;
let currentStrokeId = -1;       // the stroke being painted right now

// ── Recency filter ────────────────────────────────────────────────────────
// Only granulate the N most recently recorded buffers present in radius.
// A "buffer" = unique (source, liveBufferIdx|sampleIndex) combination.
let recencyN = 3;               // how many most-recent buffers to allow

// ── Cloud drop system ─────────────────────────────────────────────────────
// Up to 8 frozen granulating clouds, each locked to a sphere position.
// ↓ = drop cloud at cursor, ↑ = pick up (delete) nearest cloud.
// cloudSlots is a FIXED-LENGTH array (MAX_CLOUDS). null = empty slot.
// Each cloud: { slotIndex, lon, lat, color, searchRadiusDeg }
// Slot indices never shift — picking up slot 0 leaves slots 1–7 unchanged.
const MAX_CLOUDS = 8;
let cloudSlots = new Array(MAX_CLOUDS).fill(null); // fixed positions
const CLOUD_COLORS = [
  '#4fc3f7', '#81c784', '#ffb74d', '#e57373',
  '#ce93d8', '#fff176', '#80cbc4', '#ff8a65'
];

// ── Loaded samples (1-9) ──────────────────────────────────────────────────
// activeSampleIndex: which slot is currently toggled ON for painting (-1 = none)
let activeSampleIndex = -1;
let sampleColorIndex  = 0;       // cycles through SAMPLE_PAINT_COLORS
// Each slot: { buffer, name, duration, grainCursor, cropStart, cropEnd }
let samples = [];

// ── Live recording (spacebar) ─────────────────────────────────────────────
// Each entry: { buffer, grainCursor } — grows without bound
let liveRecBuffers = [];
let liveColorIndex = 0;          // cycles through LIVE_PAINT_COLORS
let liveGranulatingThisFrame = false;  // true if any live particle is selected this frame

// Current live recording working state
let isRecording        = false;
let recordingStream    = null;
let recordingNode      = null;
let recordingSourceNode = null;
let recordingRaw       = null;
let recordingWritePos  = 0;
let recordingStartTime = 0;
let liveBufferSampleCount = 0;
let recordingSampleRate = 0;
let micPermissionGranted = false;
let currentLiveBufferIdx = -1;   // index into liveRecBuffers being recorded

// ── Audio ─────────────────────────────────────────────────────────────────
let audioCtx   = null;
let masterBus  = null;
let masterAnalyser = null;
let inputGainNode  = null;   // pre-compressor gain for mic signal
let inputAnalyser  = null;   // AnalyserNode tapped after inputGain, before compressor
let inputGainValue = 1.0;    // 0.0 – 2.0, default unity

// Grain tracking for waveform playhead
let activeGrains = [];

// ── Performance monitor ───────────────────────────────────────────────────────
let perfMonitorVisible = false;
const perf = {
  frameMs:        0,    // last frame duration ms
  frameMsMax:     0,    // rolling max (resets every 2s)
  frameMsMaxAt:   0,
  schedulerDrift: 0,    // how late scheduleGrains fired vs 15ms target
  schedulerMax:   0,
  schedulerMaxAt: 0,
  grainsFired:    0,    // grains fired in last scheduler tick
  activeNodes:    0,    // running AudioBufferSource count
  audioClockLast: 0,    // audioCtx.currentTime last check
  audioClockWall: 0,    // performance.now() at that check
  underruns:      0,    // times audio clock fell behind wall clock
  lastResetAt:    0,
};
let _grainSourceCount = 0; // incremented on start, decremented on ended

function perfTick() {
  // Reset rolling maxes every 2s
  const now = performance.now();
  if (now - perf.lastResetAt > 2000) {
    perf.frameMsMax     = perf.frameMs;
    perf.schedulerMax   = perf.schedulerDrift;
    perf.lastResetAt    = now;
  }
  perf.frameMsMax   = Math.max(perf.frameMsMax,   perf.frameMs);
  perf.schedulerMax = Math.max(perf.schedulerMax, perf.schedulerDrift);
  perf.activeNodes  = _grainSourceCount;

  // Audio clock health — if audioCtx exists check it advances with wall clock
  if (audioCtx) {
    const wallElapsed  = (now - perf.audioClockWall) / 1000;
    const audioElapsed = audioCtx.currentTime - perf.audioClockLast;
    if (perf.audioClockWall > 0 && wallElapsed > 0.1) {
      if (audioElapsed < wallElapsed * 0.85) perf.underruns++; // clock lagging >15%
      perf.audioClockLast = audioCtx.currentTime;
      perf.audioClockWall = now;
    } else if (perf.audioClockWall === 0) {
      perf.audioClockLast = audioCtx.currentTime;
      perf.audioClockWall = now;
    }
  }

  if (!perfMonitorVisible) return;
  const el = document.getElementById('perfMonitor');
  if (!el) return;

  const frameColor   = perf.frameMs   > 20 ? '#e06060' : perf.frameMs   > 12 ? '#e8a030' : '#7abcbc';
  const schedColor   = perf.schedulerDrift > 10 ? '#e06060' : perf.schedulerDrift > 5 ? '#e8a030' : '#7abcbc';
  const underrunColor = perf.underruns > 0 ? '#e06060' : '#555';

  el.innerHTML =
    `<span style="color:#555">── perf monitor (P) ──</span>\n` +
    `frame  <span style="color:${frameColor}">${perf.frameMs.toFixed(1)}ms</span>  max <span style="color:#e8a030">${perf.frameMsMax.toFixed(1)}ms</span>\n` +
    `sched  <span style="color:${schedColor}">+${perf.schedulerDrift.toFixed(1)}ms</span> max <span style="color:#e8a030">+${perf.schedulerMax.toFixed(1)}ms</span>\n` +
    `grains <span style="color:#aaa">${perf.grainsFired} fired / ${perf.activeNodes} active</span>\n` +
    `underruns <span style="color:${underrunColor}">${perf.underruns}</span>`;
}

// Sample preview playback: { source, gain, startTimePerfNow, startSec, duration, slotIdx }
let samplePreviews = {};

// Overlay canvases for loaded-sample waveform playheads
let waveformOverlays = [];

// Drag-reorder state
let dragSrcIndex = -1;

// ============================================================================
// AUDIO SYSTEM
// ============================================================================

function makeSoftClipCurve(amount = 10) {
  // Tanh soft clipper: y = tanh(amount * x) / tanh(amount)
  // Higher amount = harder knee. amount=10 is near brick-wall — heavily saturates anything
  // above ~±0.3 input, smoothly, with no aliasing (oversample='4x' downstream).
  const N    = 4096; // more curve points = smoother nonlinearity at 4x oversample
  const curve = new Float32Array(N);
  const norm  = Math.tanh(amount);
  for (let i = 0; i < N; i++) {
    const x    = (i * 2) / (N - 1) - 1; // -1 to +1
    curve[i]   = Math.tanh(amount * x) / norm;
  }
  return curve;
}

function ensureAudioContext() {
  if (!audioCtx) {
    // 22050 Hz — half the default 44100/48000, halves CPU load across the entire
    // audio graph. More than enough bandwidth for trombone + voice.
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 22050 });

    // Master gain — soft clipper downstream handles the ceiling
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.9;

    // Analyser tap — post-gain, pre-clipper, for output meter
    masterAnalyser = audioCtx.createAnalyser();
    masterAnalyser.fftSize = 256;
    masterAnalyser.smoothingTimeConstant = 0.75;

    // Soft clipper (WaveShaper with tanh curve) — sample-accurate, no attack time,
    // frequency-transparent. Replaces DynamicsCompressor which was too slow for
    // transient whistle peaks and introduced frequency-dependent distortion.
    const softClipper = audioCtx.createWaveShaper();
    softClipper.curve     = makeSoftClipCurve(4);
    softClipper.oversample = '2x'; // at 22050 Hz, 2x gives 44100 Hz internal — enough to avoid aliasing

    // Chain: masterGain → analyser → softClipper → destination
    masterGain.connect(masterAnalyser);
    masterAnalyser.connect(softClipper);
    softClipper.connect(audioCtx.destination);
    masterBus = masterGain;
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function getMasterBus() { ensureAudioContext(); return masterBus; }

// ── Mic access ──────────────────────────────────────────────────────────────

function warmUpAudioEngine() {
  // Fire a zero-length silent buffer through the full grain chain so V8 JIT-compiles
  // playGrain, the WaveShaper, and all AudioNode constructors before the first real recording.
  // This eliminates the CPU spike that causes clipping on the very first spacebar press.
  const actx = ensureAudioContext();
  const silentBuf = actx.createBuffer(1, 1, actx.sampleRate);
  const src  = actx.createBufferSource();
  const gain = actx.createGain();
  const pan  = actx.createStereoPanner();
  src.buffer       = silentBuf;
  gain.gain.value  = 0;
  src.connect(gain); gain.connect(pan); pan.connect(getMasterBus());
  src.start();
  src.addEventListener('ended', () => {
    try { src.disconnect(); gain.disconnect(); pan.disconnect(); } catch(_) {}
  });
}

let audioEngineWarmedUp = false;

async function requestMicAccess() {
  if (micPermissionGranted && recordingStream) return true;
  try {
    recordingStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate:   22050,  // match AudioContext — avoids browser resampling the mic stream
        channelCount: 1,      // mono — no point capturing stereo for a trombone
        echoCancellation:    false, // off — we want the raw signal, not phone-call processing
        noiseSuppression:    false,
        autoGainControl:     false,
      }
    });
    micPermissionGranted = true;

    // Build the persistent mic → inputGain → inputAnalyser chain.
    // This stays alive as long as the mic stream is open so the input
    // meter and gain knob work even when not recording.
    const actx = ensureAudioContext();
    const monitorSrc = actx.createMediaStreamSource(recordingStream);

    inputGainNode = actx.createGain();
    inputGainNode.gain.value = inputGainValue;

    inputAnalyser = actx.createAnalyser();
    inputAnalyser.fftSize = 256;
    inputAnalyser.smoothingTimeConstant = 0.6;

    // Connect monitor chain (no destination — AnalyserNode is a dead-end tap)
    monitorSrc.connect(inputGainNode);
    inputGainNode.connect(inputAnalyser);
    // inputAnalyser is a dead-end for monitoring (no further connect needed)

    // Store monitorSrc so we can disconnect on hypothetical future cleanup
    window._micMonitorSrc = monitorSrc;

    // Warm up immediately after mic grant — before the first recording starts
    if (!audioEngineWarmedUp) {
      audioEngineWarmedUp = true;
      warmUpAudioEngine();
    }

    // Reflect ready state on the button (however mic was granted)
    const micBtn = document.getElementById('micEnableBtn');
    if (micBtn) {
      micBtn.textContent = 'mic ready';
      micBtn.classList.remove('mic-denied');
      micBtn.classList.add('mic-ready');
      micBtn.disabled = false;
    }

    return true;
  } catch (e) {
    console.warn('Mic access denied:', e);
    const micBtn = document.getElementById('micEnableBtn');
    if (micBtn) {
      micBtn.textContent = 'mic denied';
      micBtn.classList.add('mic-denied');
      micBtn.disabled = false;
    }
    return false;
  }
}

// ── Live recording ──────────────────────────────────────────────────────────

function startLiveRecording() {
  if (isRecording) return;
  if (!recordingStream) return;

  const actx = ensureAudioContext();
  recordingSampleRate   = actx.sampleRate;
  recordingRaw          = new Float32Array(recordingSampleRate * 300); // 5 min headroom
  recordingWritePos     = 0;
  liveBufferSampleCount = 0;

  // inputGainNode and inputAnalyser are created once in requestMicAccess and persist.
  // We don't need a separate MediaStreamSource for recording — tap the already-connected
  // inputAnalyser output and route it through the ScriptProcessor for capture.

  // 8192-sample buffer (~372ms at 22050 Hz) — very safe headroom at the lower sample rate.
  // Recording latency is irrelevant since we don't do live monitoring through the chain.
  recordingNode = actx.createScriptProcessor(8192, 1, 1);

  let recordingArmed = false;
  setTimeout(() => {
    recordingArmed = true;
    recordingStartTime = performance.now();
  }, 80); // tiny delay to avoid capturing the key-press click

  recordingNode.onaudioprocess = (e) => {
    if (!recordingArmed) return;
    const input = e.inputBuffer.getChannelData(0);
    if (recordingWritePos + input.length > recordingRaw.length) {
      const grown = new Float32Array(recordingRaw.length * 2);
      grown.set(recordingRaw);
      recordingRaw = grown;
    }
    recordingRaw.set(input, recordingWritePos);
    recordingWritePos += input.length;
  };

  // Chain: (persistent) inputGain → inputAnalyser → scriptProcessor → destination(dummy)
  // inputAnalyser already has inputGainNode feeding it; just attach the recorder.
  inputAnalyser.connect(recordingNode);
  recordingNode.connect(actx.destination); // ScriptProcessor must connect to keep running


  isRecording = true;

  // Reserve a slot in liveRecBuffers — placeholder with null buffer
  currentLiveBufferIdx = liveRecBuffers.length;
  liveRecBuffers.push({ buffer: null, grainCursor: 0 });

  updateLiveRecUI();
}

function stopLiveRecording() {
  if (!isRecording) return;
  isRecording = false;

  // Only tear down the recording-specific nodes.
  // inputGainNode and inputAnalyser are persistent (created in requestMicAccess)
  // so the meter and knob stay active between recordings.
  if (recordingNode) {
    recordingNode.onaudioprocess = null;
    try { inputAnalyser && inputAnalyser.disconnect(recordingNode); } catch(_) {}
    recordingNode.disconnect();
    recordingNode = null;
  }
  if (recordingSourceNode) { recordingSourceNode.disconnect(); recordingSourceNode = null; }

  const actx = ensureAudioContext();
  const totalLength = recordingWritePos;

  if (totalLength === 0) {
    // Nothing captured — remove the placeholder
    if (currentLiveBufferIdx >= 0 && currentLiveBufferIdx < liveRecBuffers.length) {
      liveRecBuffers.splice(currentLiveBufferIdx, 1);
      // Fix particle references
      particles.forEach(p => {
        if (p.liveBufferIdx === currentLiveBufferIdx) p.liveBufferIdx = -1;
        else if (p.liveBufferIdx > currentLiveBufferIdx) p.liveBufferIdx--;
      });
    }
    currentLiveBufferIdx = -1;
    recordingRaw = null;
    updateLiveRecUI();
    return;
  }

  // Build final AudioBuffer
  const audioBuffer = actx.createBuffer(1, totalLength, recordingSampleRate);
  const channelData = recordingRaw.subarray(0, totalLength);

  // Fade edges to eliminate transient clicks
  const fadeSamples = Math.min(Math.floor(recordingSampleRate * 0.05), Math.floor(totalLength / 4));
  for (let i = 0; i < fadeSamples; i++) {
    const env = (i / fadeSamples) ** 2;
    channelData[i]                    *= env;
    channelData[totalLength - 1 - i]  *= env;
  }

  audioBuffer.getChannelData(0).set(channelData);

  // Seal the live buffer slot
  const slot = liveRecBuffers[currentLiveBufferIdx];
  if (slot) {
    slot.buffer      = audioBuffer;
    slot.grainCursor = 0;
  }

  // Clamp any particles that were painted beyond the final duration
  particles.forEach(p => {
    if (p.liveBufferIdx === currentLiveBufferIdx) {
      const dur = audioBuffer.duration;
      if (p.grainStart > dur) p.grainStart = Math.max(0, dur - 0.01);
      if (p.grainStart + p.grainDuration > dur) p.grainDuration = dur - p.grainStart;
    }
  });

  console.log(`Live rec buffer ${currentLiveBufferIdx}: ${audioBuffer.duration.toFixed(2)}s`);
  recordingRaw         = null;
  recordingWritePos    = 0;
  liveBufferSampleCount = 0;
  currentLiveBufferIdx = -1;
  updateLiveRecUI();
}

function getRecordingDuration() {
  if (!isRecording) return 0;
  return (performance.now() - recordingStartTime) / 1000;
}

let lastLiveRebuildTime = 0;
const LIVE_REBUILD_INTERVAL_MS = 200; // rebuild at most every 200ms — avoids main-thread spikes

function rebuildLiveBuffer() {
  // Build a running AudioBuffer from raw PCM so grains can play during recording.
  // Throttled: createBuffer + set() on a growing array is expensive — don't do it every frame.
  if (!isRecording || recordingWritePos === 0) return;
  if (recordingWritePos === liveBufferSampleCount) return;

  const now = performance.now();
  if (now - lastLiveRebuildTime < LIVE_REBUILD_INTERVAL_MS) return;
  lastLiveRebuildTime = now;

  const actx = ensureAudioContext();
  const len = recordingWritePos;
  const liveBuffer = actx.createBuffer(1, len, recordingSampleRate);
  liveBuffer.getChannelData(0).set(recordingRaw.subarray(0, len));
  liveBufferSampleCount = len;

  if (currentLiveBufferIdx >= 0 && currentLiveBufferIdx < liveRecBuffers.length) {
    liveRecBuffers[currentLiveBufferIdx].liveBuffer = liveBuffer;
    liveRecBuffers[currentLiveBufferIdx].duration   = liveBuffer.duration;
  }
}

// ── Loaded-sample file loading ───────────────────────────────────────────────

async function loadAudioFile(file) {
  if (samples.length >= MAX_SAMPLES) {
    console.warn('Max 9 samples loaded');
    return;
  }
  const actx = ensureAudioContext();
  const arrayBuffer = await file.arrayBuffer();
  const audioBuffer = await actx.decodeAudioData(arrayBuffer);

  samples.push({
    buffer:     audioBuffer,
    name:       file.name,
    duration:   audioBuffer.duration,
    grainCursor: 0,
    cropStart:  0,
    cropEnd:    1
  });

  rebuildSampleListUI();
  console.log(`Loaded sample ${samples.length}: ${file.name} (${audioBuffer.duration.toFixed(2)}s)`);
}

// (Sample paint is now purely momentary via number key hold — no toggle function needed)

function updateSamplePaintIndicator() {
  const indicator = document.getElementById('sampleIndicator');
  if (activeSampleIndex >= 0 && activeSampleIndex < samples.length) {
    const s     = samples[activeSampleIndex];
    const color = SAMPLE_PAINT_COLORS[activeSampleIndex % SAMPLE_PAINT_COLORS.length];
    indicator.textContent = `[${activeSampleIndex + 1}] ${s.name.slice(0, 18)}`;
    indicator.style.color = color;
  } else {
    indicator.textContent = 'no sample';
    indicator.style.color = '#555';
  }
}

// ============================================================================
// UNDO SYSTEM
// ============================================================================

function recordStrokeStart(type, liveBufferIndex) {
  currentStrokeId = ++strokeIdCounter;
  strokeHistory.push({
    strokeId:       currentStrokeId,
    type,
    liveBufferIndex: liveBufferIndex !== undefined ? liveBufferIndex : -1
  });
}

function undoLastStroke() {
  if (strokeHistory.length === 0) return;
  const entry = strokeHistory.pop();
  const sid   = entry.strokeId;

  // Remove all particles belonging to this stroke
  particles = particles.filter(p => p.strokeId !== sid);

  // If it was a live stroke, remove that buffer entirely
  if (entry.type === 'live' && entry.liveBufferIndex >= 0) {
    const idx = entry.liveBufferIndex;
    if (idx < liveRecBuffers.length) {
      liveRecBuffers.splice(idx, 1);
      // Fix remaining particle references
      particles.forEach(p => {
        if (p.liveBufferIdx > idx) p.liveBufferIdx--;
      });
    }
    updateLiveRecUI();
  }
}

// ============================================================================
// GRAIN PLAYBACK
// ============================================================================

function rand(min, max) { return min + Math.random() * (max - min); }

function playGrain(particle) {
  const actx   = ensureAudioContext();
  let   buffer = null;

  if (particle.source === 'sample') {
    if (particle.sampleIndex < 0 || particle.sampleIndex >= samples.length) return;
    buffer = samples[particle.sampleIndex].buffer;
  } else if (particle.source === 'live') {
    if (particle.liveBufferIdx < 0 || particle.liveBufferIdx >= liveRecBuffers.length) return;
    const slot = liveRecBuffers[particle.liveBufferIdx];
    buffer = slot.buffer || slot.liveBuffer;
  }
  if (!buffer) return;

  // Retrigger guard in audio-clock seconds (more precise than wall clock)
  const audioNow = actx.currentTime;
  const retriggerSec = gp().retriggerMs / 1000;
  if (particle.lastTriggeredAt !== undefined && audioNow - particle.lastTriggeredAt < retriggerSec) return;
  particle.lastTriggeredAt = audioNow;

  const sampleDur    = buffer.duration;
  const cropStartSec = particle.source === 'sample'
    ? (samples[particle.sampleIndex].cropStart * sampleDur) : 0;
  const cropEndSec   = particle.source === 'sample'
    ? (samples[particle.sampleIndex].cropEnd   * sampleDur) : sampleDur;
  // Small lookahead so grains are never scheduled in the past
  const LOOKAHEAD = 0.015;
  const baseTime  = actx.currentTime + LOOKAHEAD;

  const p = gp();
  for (let i = 0; i < p.sprayCount; i++) {
    const timeOffset = i * p.spraySpread * rand(0.5, 1.5);
    const t          = baseTime + timeOffset;

    let startPos = particle.grainStart + rand(-p.startJitter, p.startJitter);
    const dur = Math.max(0.02, particle.grainDuration + rand(-p.durJitter, p.durJitter));

    // Ensure the grain window fits entirely within [cropStartSec, cropEndSec].
    // If near the start, push startPos forward so the full grain fits rather than truncating.
    // If near the end, pull startPos back so the grain isn't cut short there either.
    const cropLen = cropEndSec - cropStartSec;
    if (cropLen < dur) {
      // Buffer shorter than one grain — play whatever we have
      startPos = cropStartSec;
    } else {
      startPos = Math.max(cropStartSec, Math.min(startPos, cropEndSec - dur));
    }

    const actualDur = Math.min(dur, cropEndSec - startPos);
    // Skip grains too short to envelope cleanly
    if (actualDur < 0.015) continue;

    // Fade: at least 4ms, at most a third of grain duration
    const fade   = Math.max(0.004, Math.min(p.fade, actualDur / 3));
    const source = actx.createBufferSource();
    source.buffer = buffer;
    source.playbackRate.value = 1 + rand(-p.pitchJitter, p.pitchJitter);

    const gain    = actx.createGain();

    // ── Hann window envelope ─────────────────────────────────────────────────
    // Reuse precomputed scaled curves (rebuilt on preset change) — no per-grain allocation.
    gain.gain.setValueAtTime(0, t);
    gain.gain.setValueCurveAtTime(GRAIN_ATTACK_CURVE,  t,               fade);
    gain.gain.setValueCurveAtTime(GRAIN_RELEASE_CURVE, t + actualDur - fade, fade);

    const panner = actx.createStereoPanner();
    panner.pan.value = rand(-p.panSpread, p.panSpread);

    source.connect(gain);
    gain.connect(panner);
    panner.connect(getMasterBus());

    // Use only source.start duration — don't also call stop(), double-stop causes clicks
    source.start(t, startPos, actualDur);
    _grainSourceCount++;
    source.addEventListener('ended', () => {
      _grainSourceCount = Math.max(0, _grainSourceCount - 1);
      try { source.disconnect(); gain.disconnect(); panner.disconnect(); } catch(_){}
    });

    // Track for waveform playhead (loaded samples only)
    if (particle.source === 'sample') {
      activeGrains.push({
        sampleIndex:   particle.sampleIndex,
        grainStart:    startPos,
        grainDuration: actualDur,
        startTime:     performance.now() + timeOffset * 1000,
        totalDuration: actualDur
      });
    }
  }
}

// ============================================================================
// SAMPLE LIST UI — loaded samples only
// ============================================================================

function rebuildSampleListUI() {
  const list = document.getElementById('sampleList');
  list.innerHTML = '';
  waveformOverlays = [];

  for (let i = 0; i < MAX_SAMPLES; i++) {
    const s        = i < samples.length ? samples[i] : null;
    const isLoaded = s !== null;
    const color    = SAMPLE_PAINT_COLORS[i % SAMPLE_PAINT_COLORS.length];
    const isPaintingSlot = (i === activeSampleIndex) && isLoaded;

    const slot = document.createElement('div');
    slot.className =
      'sample-slot' +
      (isLoaded ? ' loaded' : ' empty') +
      (isPaintingSlot ? ' painting' : '');
    slot.dataset.index = i;
    slot.style.setProperty('--slot-color', color);

    // Clicks on the slot itself do nothing for painting (use number keys to paint)
    // — child buttons (play, delete) handle their own clicks via stopPropagation

    // Drag handle
    const handle = document.createElement('span');
    handle.className  = 'slot-drag-handle';
    handle.textContent = '☰';
    handle.draggable  = isLoaded;
    if (isLoaded) {
      handle.addEventListener('dragstart', e => {
        dragSrcIndex = i;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', String(i));
        slot.style.opacity = '0.4';
      });
      handle.addEventListener('dragend', () => {
        slot.style.opacity = '';
        dragSrcIndex = -1;
        list.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
      });
    }

    // Drop targets
    slot.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; slot.classList.add('drag-over'); });
    slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
    slot.addEventListener('drop', e => {
      e.preventDefault();
      slot.classList.remove('drag-over');
      const fromIdx = dragSrcIndex;
      if (fromIdx >= 0 && fromIdx !== i && fromIdx < samples.length) reorderSample(fromIdx, i);
    });

    // Key number (shows slot colour when painting)
    const key = document.createElement('span');
    key.className   = 'slot-key';
    key.textContent = i + 1;
    if (isPaintingSlot) key.style.color = color;

    // Name
    const name = document.createElement('span');
    name.className  = 'slot-name';
    name.textContent = isLoaded
      ? (s.name.length > 24 ? s.name.slice(0, 22) + '…' : s.name)
      : (i === samples.length ? 'drop to load…' : '—');

    // Duration (crop-aware)
    const dur = document.createElement('span');
    dur.className   = 'slot-duration';
    dur.textContent = isLoaded ? ((s.cropEnd - s.cropStart) * s.duration).toFixed(1) + 's' : '';

    // Play/stop button
    const playBtn = document.createElement('button');
    playBtn.className = 'slot-play';
    playBtn.textContent = '▶';
    playBtn.title       = 'Preview sample';
    if (isLoaded) {
      playBtn.addEventListener('click', e => { e.stopPropagation(); toggleSamplePreview(i, playBtn); });
      if (samplePreviews[i]) { playBtn.textContent = '■'; playBtn.classList.add('playing'); }
    }

    // Waveform canvas + crop canvas + overlay
    const waveDiv   = document.createElement('div');
    waveDiv.className = 'slot-waveform';
    const wc         = document.createElement('canvas');
    const cropCanvas = document.createElement('canvas');
    const overlay    = document.createElement('canvas');
    overlay.className = 'slot-waveform-overlay';
    waveDiv.appendChild(wc);
    waveDiv.appendChild(cropCanvas);
    waveDiv.appendChild(overlay);
    waveformOverlays[i] = isLoaded
      ? { canvas: overlay, cropCanvas, duration: s.duration, sampleIndex: i }
      : null;

    if (isLoaded) setupCropInteraction(waveDiv, cropCanvas, i);

    // Delete button
    const del = document.createElement('button');
    del.className   = 'slot-delete';
    del.textContent = '×';
    del.title       = 'Remove sample';
    if (isLoaded) {
      del.addEventListener('click', e => { e.stopPropagation(); deleteSample(i); });
    }

    slot.appendChild(handle);
    slot.appendChild(key);
    slot.appendChild(name);
    slot.appendChild(dur);
    slot.appendChild(playBtn);
    slot.appendChild(waveDiv);
    slot.appendChild(del);
    list.appendChild(slot);

    if (isLoaded) {
      const slotIdx = i;
      requestAnimationFrame(() => {
        drawSlotWaveform(wc, s.buffer);
        const rect = overlay.parentElement.getBoundingClientRect();
        if (rect.width > 0) {
          overlay.width    = rect.width * 2;
          overlay.height   = rect.height * 2;
          cropCanvas.width = rect.width * 2;
          cropCanvas.height = rect.height * 2;
          drawCropOverlay(slotIdx);
        }
      });
    }
  }
}

function updateSampleListActiveState() {
  document.querySelectorAll('.sample-slot').forEach(slot => {
    const idx   = parseInt(slot.dataset.index);
    const color = SAMPLE_PAINT_COLORS[idx % SAMPLE_PAINT_COLORS.length];
    slot.classList.toggle('painting', idx === activeSampleIndex);
    const keyEl = slot.querySelector('.slot-key');
    if (keyEl) keyEl.style.color = (idx === activeSampleIndex) ? color : '';
  });
}

function deleteSample(index) {
  if (index < 0 || index >= samples.length) return;
  stopSamplePreview(index);
  samples.splice(index, 1);

  particles.forEach(p => {
    if (p.source !== 'sample' || p.sampleIndex == null) return;
    if (p.sampleIndex === index)       p.sampleIndex = -1;
    else if (p.sampleIndex > index)    p.sampleIndex--;
  });

  if (activeSampleIndex === index)            activeSampleIndex = -1;
  else if (activeSampleIndex > index)         activeSampleIndex--;

  rebuildSampleListUI();
  updateSamplePaintIndicator();
}

function reorderSample(fromIdx, toIdx) {
  const targetIdx = Math.min(toIdx, samples.length - 1);
  if (fromIdx === targetIdx || fromIdx < 0 || fromIdx >= samples.length) return;

  const [moved] = samples.splice(fromIdx, 1);
  samples.splice(targetIdx, 0, moved);

  particles.forEach(p => {
    if (p.source !== 'sample' || p.sampleIndex == null) return;
    if (p.sampleIndex === fromIdx) {
      p.sampleIndex = targetIdx;
    } else if (fromIdx < targetIdx) {
      if (p.sampleIndex > fromIdx && p.sampleIndex <= targetIdx) p.sampleIndex--;
    } else {
      if (p.sampleIndex >= targetIdx && p.sampleIndex < fromIdx)  p.sampleIndex++;
    }
  });

  if (activeSampleIndex === fromIdx)          activeSampleIndex = targetIdx;
  else if (fromIdx < targetIdx) {
    if (activeSampleIndex > fromIdx && activeSampleIndex <= targetIdx) activeSampleIndex--;
  } else {
    if (activeSampleIndex >= targetIdx && activeSampleIndex < fromIdx) activeSampleIndex++;
  }

  rebuildSampleListUI();
  updateSamplePaintIndicator();
}

// ── Grain presets UI ─────────────────────────────────────────────────────────

function setupPresets() {
  const container = document.getElementById('presetButtons');
  PRESETS.forEach((preset, i) => {
    const btn = document.createElement('button');
    btn.className = 'preset-btn' + (i === 0 ? ' active' : '');
    btn.textContent = preset.name;
    btn.addEventListener('click', () => selectPreset(i));
    container.appendChild(btn);
  });
  drawPresetWaveform();
  updatePresetStats();

  // Snap toggle button
  const snapBtn = document.getElementById('snapToggleBtn');
  if (snapBtn) snapBtn.addEventListener('click', toggleNearestMode);

  // Recency filter +/- buttons
  const recencyValEl = document.getElementById('recencyVal');
  document.getElementById('recencyDec')?.addEventListener('click', () => {
    recencyN = Math.max(1, recencyN - 1);
    if (recencyValEl) recencyValEl.textContent = recencyN;
  });
  document.getElementById('recencyInc')?.addEventListener('click', () => {
    recencyN = Math.min(16, recencyN + 1);
    if (recencyValEl) recencyValEl.textContent = recencyN;
  });

  // Mic enable button — request permission early so the first recording isn't clippy
  const micBtn = document.getElementById('micEnableBtn');
  if (micBtn) {
    micBtn.addEventListener('click', async () => {
      if (micPermissionGranted) return; // already enabled
      micBtn.textContent = 'enabling…';
      micBtn.disabled = true;
      ensureAudioContext();
      const ok = await requestMicAccess();
      if (ok) {
        micBtn.textContent = 'mic ready';
        micBtn.classList.add('mic-ready');
        // Hold here briefly — let the audio engine fully settle before user records
        // (warmUpAudioEngine already fired inside requestMicAccess)
      } else {
        micBtn.textContent = 'mic denied';
        micBtn.classList.add('mic-denied');
      }
      micBtn.disabled = false;
    });
  }
}

function toggleNearestMode() {
  nearestMode = !nearestMode;
  updatePlaybackControls();
}

// ── Cloud drop / pickup ───────────────────────────────────────────────────
function dropCloud() {
  // Find the first empty slot
  const slotIndex = cloudSlots.indexOf(null);
  if (slotIndex === -1) return; // all 8 slots occupied
  const { lon, lat } = mouseInCanvas ? getMouseLonLat() : getCursorLonLat();
  const color = CLOUD_COLORS[slotIndex]; // color is fixed to slot position
  cloudSlots[slotIndex] = { slotIndex, lon, lat, color, searchRadiusDeg };
  updateCloudBanksUI();
}

function pickupNearestCloud() {
  const { lon, lat } = mouseInCanvas ? getMouseLonLat() : getCursorLonLat();
  // Find the nearest occupied slot by sphere angle
  let nearestSlot = -1;
  let nearestAng = Infinity;
  for (let i = 0; i < MAX_CLOUDS; i++) {
    if (!cloudSlots[i]) continue;
    const ang = angleBetweenSphere(cloudSlots[i].lon, cloudSlots[i].lat, lon, lat);
    if (ang < nearestAng) { nearestAng = ang; nearestSlot = i; }
  }
  if (nearestSlot === -1) return;
  cloudSlots[nearestSlot] = null; // null the slot — index stays, others unaffected
  updateCloudBanksUI();
}

function updateCloudBanksUI() {
  // Each DOM slot maps 1-to-1 with cloudSlots[i] — indices never shift.
  const domSlots = document.querySelectorAll('.cloud-slot');
  const { lon: curLon, lat: curLat } = mouseInCanvas ? getMouseLonLat() : getCursorLonLat();
  const nearestSlot = findNearestCloudSlot(curLon, curLat);

  domSlots.forEach((domSlot, i) => {
    const cloud = cloudSlots[i];
    // Show slot number label always
    domSlot.textContent = i + 1;
    domSlot.className = 'cloud-slot';
    if (cloud) {
      domSlot.style.cssText = `background:${cloud.color}33;border-color:${cloud.color};color:${cloud.color}`;
      domSlot.classList.add(i === nearestSlot ? 'cloud-slot--nearest' : 'cloud-slot--active');
    } else {
      domSlot.style.cssText = '';
      domSlot.classList.add('cloud-slot--empty');
    }
  });
}

function selectPreset(index) {
  activePresetIndex = index;
  grainParams = { ...PRESETS[index] };
  rebuildHannCurves(grainParams.volume); // rebuild scaled Hann curves for new volume
  document.querySelectorAll('.preset-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
  drawPresetWaveform();
  updatePresetStats();
  updatePlaybackControls();
}

function updatePlaybackControls() {
  // Snap toggle button
  const snapBtn = document.getElementById('snapToggleBtn');
  if (snapBtn) {
    snapBtn.classList.toggle('active', nearestMode);
    snapBtn.textContent = nearestMode ? 'snap: on' : 'snap: off';
  }
  // Radius canvas
  drawRadiusViz();
  // HUD indicator (kept small, just shows mode)
  const el = document.getElementById('radiusIndicator');
  if (!el) return;
  if (nearestMode) {
    el.textContent = 'snap';
    el.style.color = '#e8a030';
  } else {
    el.textContent = `r: ${searchRadiusDeg}°`;
    el.style.color = '#7abcbc';
  }
}

function drawRadiusViz() {
  const canvas = document.getElementById('radiusViz');
  if (!canvas) return;
  const rect = canvas.parentElement.getBoundingClientRect();
  const w = rect.width  || 180;
  const h = rect.height || 48;
  canvas.width  = w * window.devicePixelRatio;
  canvas.height = h * window.devicePixelRatio;
  const c = canvas.getContext('2d');
  c.scale(window.devicePixelRatio, window.devicePixelRatio);
  c.clearRect(0, 0, w, h);

  const cx = w / 2, cy = h / 2;

  if (nearestMode) {
    // Snap mode — draw a diamond + "snap" label
    const d = Math.min(w, h) * 0.28;
    c.strokeStyle = '#e8a030';
    c.lineWidth = 1.5;
    c.shadowColor = '#e8a030';
    c.shadowBlur = 6;
    c.beginPath();
    c.moveTo(cx,     cy - d);
    c.lineTo(cx + d, cy    );
    c.lineTo(cx,     cy + d);
    c.lineTo(cx - d, cy    );
    c.closePath();
    c.stroke();
    c.shadowBlur = 0;
    // centre dot
    c.fillStyle = '#e8a030';
    c.beginPath(); c.arc(cx, cy, 2.5, 0, Math.PI * 2); c.fill();
    // label
    c.fillStyle = '#e8a03088';
    c.font = `${Math.round(h * 0.22)}px "Roboto Mono", monospace`;
    c.textAlign = 'center';
    c.textBaseline = 'bottom';
    c.fillText('nearest', cx, h - 3);
  } else {
    // Radius mode — draw an arc whose angular size represents the radius
    // Map searchRadiusDeg (1–180) to a visual circle radius (min=6px, max fills canvas)
    const maxR = Math.min(cx, cy) - 4;
    const minR = 5;
    const t = (searchRadiusDeg - 1) / (180 - 1);
    const r = minR + t * (maxR - minR);

    // Faint full circle guide
    c.strokeStyle = '#333';
    c.lineWidth = 1;
    c.beginPath(); c.arc(cx, cy, maxR, 0, Math.PI * 2); c.stroke();

    // Radius arc (teal)
    c.strokeStyle = '#7abcbc';
    c.lineWidth = 1.5;
    c.shadowColor = '#7abcbc';
    c.shadowBlur = searchRadiusDeg > 90 ? 8 : 4;
    c.beginPath(); c.arc(cx, cy, r, 0, Math.PI * 2); c.stroke();
    c.shadowBlur = 0;

    // Centre dot
    c.fillStyle = 'rgba(255,255,255,0.4)';
    c.beginPath(); c.arc(cx, cy, 2, 0, Math.PI * 2); c.fill();

    // Degree label inside or below
    c.fillStyle = '#7abcbc99';
    c.font = `${Math.round(h * 0.22)}px "Roboto Mono", monospace`;
    c.textAlign = 'center';
    c.textBaseline = 'bottom';
    c.fillText(`${searchRadiusDeg}°`, cx, h - 3);
  }
}

function drawPresetWaveform() {
  const canvas = document.getElementById('presetWaveform');
  if (!canvas) return;
  const rect = canvas.parentElement.getBoundingClientRect();
  const w = rect.width  || 180;
  const h = rect.height || 48;
  canvas.width  = w * window.devicePixelRatio;
  canvas.height = h * window.devicePixelRatio;
  const c = canvas.getContext('2d');
  c.scale(window.devicePixelRatio, window.devicePixelRatio);
  c.clearRect(0, 0, w, h);

  const pr = PRESETS[activePresetIndex];

  // Draw overlapping grain envelopes as smooth Hann (raised cosine) bumps
  // Period = duration - overlap (stride between grain onsets)
  const period   = Math.max(pr.duration - pr.overlap, 0.005);
  const viewSec  = 0.8;
  const pxPerSec = w / viewSec;
  const grainW   = pr.duration * pxPerSec;
  const midY     = h / 2;
  const maxAmp   = h * 0.38;

  // Colour: active preset tint
  const tints = ['#7abcbc', '#6090e0', '#e07060'];
  const tint  = tints[activePresetIndex] || '#7abcbc';

  // Draw multiple grains staggered in time, randomise slightly
  const count  = Math.ceil(viewSec / period) + 2;
  const STEPS  = 64; // curve resolution

  for (let i = -1; i < count; i++) {
    const jit    = (Math.sin(i * 7.3) * 0.5 + 0.5) * pr.startJitter * pxPerSec * 0.4;
    const xStart = i * period * pxPerSec - grainW * 0.15 + jit;

    // Build Hann curve path: y = 0.5*(1 - cos(π*t)) for t in [0,1]
    c.beginPath();
    for (let s = 0; s <= STEPS; s++) {
      const t    = s / STEPS;
      const hann = 0.5 * (1 - Math.cos(Math.PI * t));
      const x    = xStart + t * grainW;
      const y    = midY - hann * maxAmp;
      if (s === 0) c.moveTo(x, y); else c.lineTo(x, y);
    }
    // Close path back along baseline for fill
    c.lineTo(xStart + grainW, midY);
    c.lineTo(xStart, midY);
    c.closePath();

    c.globalAlpha = 0.08;
    c.fillStyle = tint;
    c.fill();

    // Stroke just the curve (not the baseline)
    c.beginPath();
    for (let s = 0; s <= STEPS; s++) {
      const t    = s / STEPS;
      const hann = 0.5 * (1 - Math.cos(Math.PI * t));
      const x    = xStart + t * grainW;
      const y    = midY - hann * maxAmp;
      if (s === 0) c.moveTo(x, y); else c.lineTo(x, y);
    }
    c.globalAlpha = 0.6;
    c.strokeStyle = tint;
    c.lineWidth = 1.5;
    c.stroke();
  }
  c.globalAlpha = 1;

  // Centre line
  c.globalAlpha = 0.2;
  c.strokeStyle = '#ffffff';
  c.lineWidth = 0.5;
  c.beginPath();
  c.moveTo(0, midY); c.lineTo(w, midY);
  c.stroke();
  c.globalAlpha = 1;
}

function updatePresetStats() {
  const pr = PRESETS[activePresetIndex];
  const durEl = document.getElementById('psDur');
  const kEl   = document.getElementById('psK');
  const panEl = document.getElementById('psPan');
  if (durEl) durEl.textContent = Math.round(pr.duration * 1000) + 'ms';
  if (kEl)   kEl.textContent   = pr.k === 0 ? 'nearest' : pr.k;
  if (panEl) panEl.textContent = Math.round(pr.panSpread * 100) + '%';
}

// ── Live rec UI ──────────────────────────────────────────────────────────────

function updateLiveGranulatingIndicator() {
  const el = document.getElementById('liveGranulating');
  if (!el) return;
  if (liveGranulatingThisFrame) {
    el.classList.add('active');
  } else {
    el.classList.remove('active');
  }
}

function updateLiveRecUI() {
  const countEl = document.getElementById('liveRecCount');
  const span    = countEl.querySelector('span');
  if (span) span.textContent = liveRecBuffers.filter(b => b.buffer !== null).length;

  const status  = document.getElementById('liveRecStatus');
  if (isRecording) {
    status.className = 'recording';
    status.innerHTML = '<span class="rec-dot"></span>recording…';
  } else {
    status.className = '';
    status.textContent = 'space: rec+paint';
  }
}

// ============================================================================
// WAVEFORM DRAWING — loaded samples
// ============================================================================

function drawSlotWaveform(wc, buffer) {
  const rect = wc.parentElement.getBoundingClientRect();
  if (rect.width === 0) return;
  wc.width  = rect.width * 2;
  wc.height = rect.height * 2;
  const wctx = wc.getContext('2d');
  const data = buffer.getChannelData(0);
  const step = Math.max(1, Math.floor(data.length / wc.width));
  const mid  = wc.height / 2;
  wctx.clearRect(0, 0, wc.width, wc.height);
  wctx.strokeStyle = '#7abcbc';
  wctx.lineWidth   = 1;
  wctx.beginPath();
  for (let i = 0; i < wc.width; i++) {
    const idx = i * step;
    let min = 0, max = 0;
    for (let j = 0; j < step && idx + j < data.length; j++) {
      const v = data[idx + j];
      if (v < min) min = v;
      if (v > max) max = v;
    }
    wctx.moveTo(i, mid + min * mid);
    wctx.lineTo(i, mid + max * mid);
  }
  wctx.stroke();
}

const CROP_HANDLE_W = 6;

function drawCropOverlay(slotIdx) {
  const ov = waveformOverlays[slotIdx];
  if (!ov || !ov.cropCanvas) return;
  const s = samples[slotIdx];
  if (!s) return;

  const cc   = ov.cropCanvas;
  const cctx = cc.getContext('2d');
  const w    = cc.width;
  const h    = cc.height;
  cctx.clearRect(0, 0, w, h);

  const xStart = s.cropStart * w;
  const xEnd   = s.cropEnd   * w;

  cctx.fillStyle = 'rgba(0,0,0,0.55)';
  if (xStart > 0)  cctx.fillRect(0,     0, xStart,     h);
  if (xEnd   < w)  cctx.fillRect(xEnd,  0, w - xEnd,   h);

  const hw = CROP_HANDLE_W * 2;
  cctx.fillStyle = '#e0c860';
  cctx.fillRect(xStart - hw / 2, 0, hw, h);
  cctx.fillRect(xEnd   - hw / 2, 0, hw, h);

  cctx.fillStyle = 'rgba(224,200,96,0.4)';
  cctx.fillRect(xStart, 0,     xEnd - xStart, 2);
  cctx.fillRect(xStart, h - 2, xEnd - xStart, 2);
}

function setupCropInteraction(waveDiv, cropCanvas, slotIdx) {
  let dragging = null;
  const HANDLE_HIT = 8;

  function getHandleHit(e) {
    const rect = waveDiv.getBoundingClientRect();
    const x    = e.clientX - rect.left;
    const w    = rect.width;
    const s    = samples[slotIdx];
    if (!s) return null;
    if (Math.abs(x - s.cropStart * w) <= HANDLE_HIT) return 'start';
    if (Math.abs(x - s.cropEnd   * w) <= HANDLE_HIT) return 'end';
    return null;
  }

  // Hover: add/remove CSS class on waveDiv to show col-resize near handles
  waveDiv.addEventListener('mousemove', e => {
    if (dragging) return; // cursor already locked via body during drag
    waveDiv.classList.toggle('near-handle', !!getHandleHit(e));
  });
  waveDiv.addEventListener('mouseleave', () => {
    if (!dragging) waveDiv.classList.remove('near-handle');
  });

  // Drag start
  waveDiv.addEventListener('mousedown', e => {
    const hit = getHandleHit(e);
    if (!hit) return;
    e.preventDefault();
    e.stopPropagation();
    dragging = hit;
    document.body.style.cursor = 'col-resize';
  });

  // Drag move — on document so it works even if mouse leaves waveDiv
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const rect = waveDiv.getBoundingClientRect();
    const x    = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
    const norm = x / rect.width;
    const s    = samples[slotIdx];
    if (!s) return;
    const minSpan = 0.02;
    if (dragging === 'start') s.cropStart = Math.max(0, Math.min(norm, s.cropEnd   - minSpan));
    else                      s.cropEnd   = Math.min(1, Math.max(norm, s.cropStart + minSpan));
    drawCropOverlay(slotIdx);
    updateCropDuration(slotIdx);
  });

  // Drag end
  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = null;
    document.body.style.cursor = '';
    waveDiv.classList.remove('near-handle');
    const s = samples[slotIdx];
    if (s) s.grainCursor = s.cropStart * s.duration;
  });
}

function updateCropDuration(slotIdx) {
  const s    = samples[slotIdx];
  if (!s)    return;
  const slot = document.querySelector(`.sample-slot[data-index="${slotIdx}"] .slot-duration`);
  if (slot)  slot.textContent = ((s.cropEnd - s.cropStart) * s.duration).toFixed(1) + 's';
}

// ── Sample preview playback ──────────────────────────────────────────────────

function toggleSamplePreview(slotIdx, btn) {
  if (samplePreviews[slotIdx]) { stopSamplePreview(slotIdx); return; }
  const s = samples[slotIdx];
  if (!s || !s.buffer) return;

  const actx     = ensureAudioContext();
  const startSec = s.cropStart * s.duration;
  const endSec   = s.cropEnd   * s.duration;
  const dur      = endSec - startSec;

  const source = actx.createBufferSource();
  source.buffer = s.buffer;
  const gain = actx.createGain();
  gain.gain.value = gp().volume;
  source.connect(gain);
  gain.connect(getMasterBus());
  source.start(actx.currentTime, startSec, dur);

  const preview = { source, gain, startTimePerfNow: performance.now(), startSec, duration: dur, slotIdx };
  samplePreviews[slotIdx] = preview;

  activeGrains.push({
    sampleIndex:   slotIdx,
    grainStart:    startSec,
    grainDuration: dur,
    startTime:     performance.now(),
    totalDuration: dur
  });

  btn.textContent = '■';
  btn.classList.add('playing');

  source.onended = () => {
    if (samplePreviews[slotIdx] === preview) {
      delete samplePreviews[slotIdx];
      btn.textContent = '▶';
      btn.classList.remove('playing');
    }
  };
}

function stopSamplePreview(slotIdx) {
  const preview = samplePreviews[slotIdx];
  if (!preview) return;
  try { preview.source.stop(); } catch (e) {}
  delete samplePreviews[slotIdx];
  const btn = document.querySelector(`.sample-slot[data-index="${slotIdx}"] .slot-play`);
  if (btn) { btn.textContent = '▶'; btn.classList.remove('playing'); }
}

// ── Waveform playhead overlay ────────────────────────────────────────────────

function updateWaveformPlayheads() {
  const now = performance.now();
  activeGrains = activeGrains.filter(g => now < g.startTime + g.totalDuration * 1000);

  const grainsBySample = {};
  for (const g of activeGrains) {
    if (!grainsBySample[g.sampleIndex]) grainsBySample[g.sampleIndex] = [];
    grainsBySample[g.sampleIndex].push(g);
  }

  for (let i = 0; i < MAX_SAMPLES; i++) {
    const ov = waveformOverlays[i];
    if (!ov || !ov.canvas || ov.canvas.width === 0) continue;
    const octx   = ov.canvas.getContext('2d');
    const w      = ov.canvas.width;
    const h      = ov.canvas.height;
    octx.clearRect(0, 0, w, h);

    const grains = grainsBySample[i];
    if (!grains || grains.length === 0) continue;
    const sampleDur = (i < samples.length && samples[i].duration > 0) ? samples[i].duration : ov.duration;
    if (sampleDur <= 0) continue;

    for (const g of grains) {
      const elapsed  = (now - g.startTime) / 1000;
      const currentPos = g.grainStart + elapsed;
      const xPos     = (currentPos / sampleDur) * w;
      const xStart   = (g.grainStart / sampleDur) * w;
      const xWidth   = Math.max(2, (g.grainDuration / sampleDur) * w);

      const fade = Math.min(gp().fade, g.totalDuration / 3);
      let alpha  = 1;
      if (elapsed < fade)                      alpha = elapsed / fade;
      else if (elapsed > g.totalDuration - fade) alpha = (g.totalDuration - elapsed) / fade;
      alpha = Math.max(0, Math.min(1, alpha));

      octx.fillStyle   = `rgba(255,220,80,${0.12 * alpha})`;
      octx.fillRect(xStart, 0, xWidth, h);
      octx.strokeStyle = `rgba(255,200,50,${0.4 * alpha})`;
      octx.lineWidth   = 5;
      octx.beginPath(); octx.moveTo(xPos, 0); octx.lineTo(xPos, h); octx.stroke();
      octx.strokeStyle = `rgba(255,230,80,${0.95 * alpha})`;
      octx.lineWidth   = 2;
      octx.beginPath(); octx.moveTo(xPos, 0); octx.lineTo(xPos, h); octx.stroke();
    }
  }
}

// ============================================================================
// DRAG AND DROP
// ============================================================================

function setupDragDrop() {
  const overlay = document.getElementById('dropOverlay');
  let dragCounter = 0;

  document.body.addEventListener('dragenter', e => {
    if (e.dataTransfer.types.includes('text/plain') && !e.dataTransfer.types.includes('Files')) return;
    e.preventDefault();
    if (++dragCounter === 1) overlay.classList.add('visible');
  });
  document.body.addEventListener('dragleave', e => {
    e.preventDefault();
    if (--dragCounter <= 0) { dragCounter = 0; overlay.classList.remove('visible'); }
  });
  document.body.addEventListener('dragover', e => e.preventDefault());
  document.body.addEventListener('drop', e => {
    e.preventDefault();
    dragCounter = 0;
    overlay.classList.remove('visible');
    if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) return;
    const files = [...e.dataTransfer.files].filter(f =>
      f.type.startsWith('audio/') || /\.(wav|mp3|ogg|m4a|flac|aac|webm)$/i.test(f.name)
    );
    (async () => { for (const file of files) { if (samples.length >= MAX_SAMPLES) break; await loadAudioFile(file); } })();
  });
}

// ============================================================================
// INIT
// ============================================================================

function init() {
  canvas = document.getElementById('sphereCanvas');
  ctx    = canvas.getContext('2d');
  resizeCanvas();
  setupEvents();
  setupDragDrop();
  rebuildSampleListUI();
  updateLiveRecUI();
  setupPresets();
  setupMappingModal();
  initMidi();
  // Re-size after first layout pass in case dimensions weren't settled yet
  requestAnimationFrame(() => { resizeCanvas(); drawPresetWaveform(); updatePlaybackControls(); animate(); });

  // Grain scheduler — independent of render loop so slow frames don't delay grains.
  // 15ms interval = ~67 "ticks"/sec. The retriggerMs guard inside playGrain
  // prevents over-triggering; this just ensures scheduling is never frame-starved.
  setInterval(scheduleGrains, 15);
}


function resizeCanvas() {
  const rect   = canvas.parentElement.getBoundingClientRect();
  // Guard against zero dimensions (can happen before layout is complete)
  if (rect.width === 0 || rect.height === 0) return;
  canvas.width  = rect.width;
  canvas.height = rect.height;
}

// ============================================================================
// QUATERNION MATH
// ============================================================================

function qMul(a, b) {
  return [
    a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3],
    a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2],
    a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1],
    a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]
  ];
}
function qNormalize(q) {
  const len = Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]+q[3]*q[3]);
  return [q[0]/len, q[1]/len, q[2]/len, q[3]/len];
}
function qFromAxisAngle(ax, ay, az, angle) {
  const half = angle / 2, s = Math.sin(half);
  return [Math.cos(half), ax*s, ay*s, az*s];
}
function qConjugate(q) { return [q[0], -q[1], -q[2], -q[3]]; }
function qRotateVec(q, v) {
  const vq = [0, v[0], v[1], v[2]];
  const r  = qMul(qMul(q, vq), qConjugate(q));
  return [r[1], r[2], r[3]];
}

// ============================================================================
// 3D MATH — INSIDE-SPHERE CAMERA
// ============================================================================

function spherePoint(lon, lat) {
  return [
    SPHERE_RADIUS * Math.cos(lat) * Math.cos(lon),
    SPHERE_RADIUS * Math.sin(lat),
    SPHERE_RADIUS * Math.cos(lat) * Math.sin(lon)
  ];
}
function cameraTransform(x, y, z) {
  return qRotateVec(qConjugate(camQ), [x, y, z]);
}
function project(x, y, z) {
  if (z <= 0.1) return null;
  const fovRad   = (FOV_DEG * Math.PI) / 180;
  const focalLen = (canvas.width / 2) / Math.tan(fovRad / 2);
  return {
    sx:    canvas.width  / 2 + (x / z) * focalLen,
    sy:    canvas.height / 2 - (y / z) * focalLen,
    depth: z
  };
}
function getCursorLonLat() {
  const forward = qRotateVec(camQ, [0, 0, 1]);
  return {
    lon: Math.atan2(forward[2], forward[0]),
    lat: Math.asin(Math.max(-1, Math.min(1, forward[1])))
  };
}
function screenToLonLat(px, py) {
  const fovRad   = (FOV_DEG * Math.PI) / 180;
  const focalLen = (canvas.width / 2) / Math.tan(fovRad / 2);
  const dx = (px - canvas.width  / 2) / focalLen;
  const dy = -(py - canvas.height / 2) / focalLen;
  const dz = 1;
  const len = Math.sqrt(dx*dx + dy*dy + dz*dz);
  const world = qRotateVec(camQ, [dx/len, dy/len, dz/len]);
  return {
    lon: Math.atan2(world[2], world[0]),
    lat: Math.asin(Math.max(-1, Math.min(1, world[1])))
  };
}
function getMouseLonLat() { return screenToLonLat(mousePixelX, mousePixelY); }

// ============================================================================
// RENDERING
// ============================================================================

// ── Input level meter ─────────────────────────────────────────────────────────
let inputClipHoldUntil = 0;
const INPUT_CLIP_HOLD_S = 1.5;
// Preallocated read buffer for analyser — avoids new Float32Array every frame
const ANALYSER_BUF = new Float32Array(128); // fftSize=256 → frequencyBinCount=128

function drawInputMeter() {
  const meterCanvas = document.getElementById('inputMeterCanvas');
  const clipDot     = document.getElementById('inputClipDot');
  if (!meterCanvas || !inputAnalyser) {
    // No active recording — clear meter
    if (meterCanvas) {
      const mc = meterCanvas.getContext('2d');
      mc.clearRect(0, 0, meterCanvas.width, meterCanvas.height);
    }
    if (clipDot) clipDot.classList.remove('clipping');
    return;
  }

  inputAnalyser.getFloatTimeDomainData(ANALYSER_BUF);
  const buf = ANALYSER_BUF;
  const bufLen = buf.length;

  let sumSq = 0, peak = 0;
  for (let i = 0; i < bufLen; i++) {
    const v = Math.abs(buf[i]);
    sumSq += v * v;
    if (v > peak) peak = v;
  }
  const rms = Math.sqrt(sumSq / bufLen);

  const DB_FLOOR = -60;
  const rmsDb  = rms  > 0 ? 20 * Math.log10(rms)  : DB_FLOOR;
  const peakDb = peak > 0 ? 20 * Math.log10(peak) : DB_FLOOR;
  const level  = Math.max(0, Math.min(1, (rmsDb - DB_FLOOR) / -DB_FLOOR));

  const w = meterCanvas.offsetWidth  || meterCanvas.parentElement.clientWidth || 60;
  const h = meterCanvas.offsetHeight || 4;
  if (meterCanvas.width  !== w) meterCanvas.width  = w;
  if (meterCanvas.height !== h) meterCanvas.height = h;

  const mc = meterCanvas.getContext('2d');
  mc.clearRect(0, 0, w, h);

  const fillW = Math.round(level * w);
  if (fillW > 0) {
    const grad = mc.createLinearGradient(0, 0, w, 0);
    grad.addColorStop(0,    '#3a7a50');
    grad.addColorStop(0.6,  '#5ab870');
    grad.addColorStop(0.78, '#c8b840');
    grad.addColorStop(0.9,  '#d06030');
    grad.addColorStop(1.0,  '#c03030');
    mc.fillStyle = grad;
    mc.fillRect(0, 0, fillW, h);
  }

  const now = performance.now() / 1000;
  if (peakDb >= 0) inputClipHoldUntil = now + INPUT_CLIP_HOLD_S;
  if (clipDot) clipDot.classList.toggle('clipping', now < inputClipHoldUntil);
}

// ── Output level meter ────────────────────────────────────────────────────────
let meterClipHoldUntil = 0;
const METER_CLIP_HOLD_S = 1.5; // seconds to keep clip dot lit

function drawOutputMeter() {
  const meterCanvas = document.getElementById('outputMeterCanvas');
  const clipDot     = document.getElementById('meterClipDot');
  if (!meterCanvas || !masterAnalyser) return;

  masterAnalyser.getFloatTimeDomainData(ANALYSER_BUF);
  const buf = ANALYSER_BUF;
  const bufLen = buf.length;

  // RMS + peak
  let sumSq = 0, peak = 0;
  for (let i = 0; i < bufLen; i++) {
    const v = Math.abs(buf[i]);
    sumSq += v * v;
    if (v > peak) peak = v;
  }
  const rms = Math.sqrt(sumSq / bufLen);

  // Convert to dBFS then normalise to 0-1 for display (floor -60 dBFS)
  const DB_FLOOR = -60;
  const rmsDb  = rms  > 0 ? 20 * Math.log10(rms)  : DB_FLOOR;
  const peakDb = peak > 0 ? 20 * Math.log10(peak) : DB_FLOOR;
  const level  = Math.max(0, Math.min(1, (rmsDb  - DB_FLOOR) / -DB_FLOOR));

  // Draw bar
  const w = meterCanvas.offsetWidth  || meterCanvas.parentElement.clientWidth  || 80;
  const h = meterCanvas.offsetHeight || 8;
  if (meterCanvas.width !== w)  meterCanvas.width  = w;
  if (meterCanvas.height !== h) meterCanvas.height = h;

  const mc = meterCanvas.getContext('2d');
  mc.clearRect(0, 0, w, h);

  const fillW = Math.round(level * w);
  if (fillW > 0) {
    // gradient: green → yellow → red
    const grad = mc.createLinearGradient(0, 0, w, 0);
    grad.addColorStop(0,    '#3a7a50'); // dark green
    grad.addColorStop(0.6,  '#5ab870'); // green
    grad.addColorStop(0.78, '#c8b840'); // yellow
    grad.addColorStop(0.9,  '#d06030'); // orange
    grad.addColorStop(1.0,  '#c03030'); // red
    mc.fillStyle = grad;
    mc.fillRect(0, 0, fillW, h);
  }

  // Clip detection (peak >= 0 dBFS)
  const now = performance.now() / 1000;
  if (peakDb >= 0) meterClipHoldUntil = now + METER_CLIP_HOLD_S;
  const clipping = now < meterClipHoldUntil;
  if (clipDot) clipDot.classList.toggle('clipping', clipping);

  // ── Also draw to bottom meter bar ─────────────────────────────────────────
  const meterCanvasB = document.getElementById('outputMeterCanvasBottom');
  const clipDotB     = document.getElementById('meterClipDotBottom');
  if (meterCanvasB) {
    const wb = meterCanvasB.offsetWidth  || meterCanvasB.parentElement.clientWidth || 200;
    const hb = meterCanvasB.offsetHeight || 6;
    if (meterCanvasB.width  !== wb) meterCanvasB.width  = wb;
    if (meterCanvasB.height !== hb) meterCanvasB.height = hb;
    const mcb = meterCanvasB.getContext('2d');
    mcb.clearRect(0, 0, wb, hb);
    const fillWb = Math.round(level * wb);
    if (fillWb > 0) {
      const gradb = mcb.createLinearGradient(0, 0, wb, 0);
      gradb.addColorStop(0,    '#3a7a50');
      gradb.addColorStop(0.6,  '#5ab870');
      gradb.addColorStop(0.78, '#c8b840');
      gradb.addColorStop(0.9,  '#d06030');
      gradb.addColorStop(1.0,  '#c03030');
      mcb.fillStyle = gradb;
      mcb.fillRect(0, 0, fillWb, hb);
    }
    if (clipDotB) clipDotB.classList.toggle('clipping', clipping);
  }
}

function drawFrame() {
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawGridLines();
  drawParticles();
  updateLiveGranulatingIndicator();
  drawTetherLine();
  drawCursor();
  drawClouds();
  drawOutputMeter();
  drawInputMeter();
}

function drawClouds() {
  const { lon: curLon, lat: curLat } = mouseInCanvas ? getMouseLonLat() : getCursorLonLat();
  const nearestSlot = findNearestCloudSlot(curLon, curLat);

  for (let i = 0; i < MAX_CLOUDS; i++) {
    const cloud = cloudSlots[i];
    if (!cloud) continue;

    const [wx, wy, wz] = spherePoint(cloud.lon, cloud.lat);
    const [cx, cy, cz] = cameraTransform(wx, wy, wz);
    const proj = project(cx, cy, cz);
    if (!proj) continue;

    const isNearest = i === nearestSlot;
    const rRad = cloud.searchRadiusDeg * Math.PI / 180;
    // Compute screen radius from angular size + cloud depth, not from a
    // single offset point (which rotates with the camera and fluctuates).
    const fovRad   = (FOV_DEG * Math.PI) / 180;
    const focalLen = (canvas.width / 2) / Math.tan(fovRad / 2);
    // proj.depth is the z distance in camera space; use it to get px/rad
    const screenR  = focalLen * Math.tan(rRad) / (proj.depth / SPHERE_RADIUS);

    ctx.save();
    ctx.globalAlpha = isNearest ? 0.7 : 0.4;
    ctx.strokeStyle = cloud.color;
    ctx.lineWidth = isNearest ? 2 : 1;
    ctx.setLineDash([4, 6]);
    ctx.beginPath();
    ctx.arc(proj.sx, proj.sy, Math.max(12, screenR), 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = isNearest ? 1 : 0.6;
    ctx.fillStyle = cloud.color;
    if (isNearest) { ctx.shadowColor = cloud.color; ctx.shadowBlur = 10; }
    ctx.beginPath(); ctx.arc(proj.sx, proj.sy, 4, 0, Math.PI * 2); ctx.fill();
    // Slot number label on sphere
    ctx.shadowBlur = 0;
    ctx.globalAlpha = isNearest ? 0.9 : 0.5;
    ctx.fillStyle = cloud.color;
    ctx.font = `10px "Roboto Mono", monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(i + 1, proj.sx, proj.sy - 12);
    ctx.restore();
  }
}

function drawTetherLine() {
  if (!mouseInCanvas) return;
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const dx = mousePixelX - cx, dy = mousePixelY - cy;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist < 20) return;
  const maxDist = Math.min(canvas.width, canvas.height) * 0.5;
  const alpha   = Math.min(0.5, 0.1 + 0.4 * (dist / maxDist));
  ctx.save();
  ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
  ctx.lineWidth   = 1;
  ctx.setLineDash([4, 8]);
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(mousePixelX, mousePixelY);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function drawGridLines() {
  for (let i = 0; i < GRID_SEGMENTS_LON; i++) {
    const lon = (i / GRID_SEGMENTS_LON) * Math.PI * 2;
    ctx.strokeStyle = GRID_COLOR;
    ctx.lineWidth   = 0.8;
    ctx.globalAlpha = 0.45;
    drawArc(lon, 'lon');
  }
  for (let i = 1; i < GRID_SEGMENTS_LAT; i++) {
    const lat          = (i / GRID_SEGMENTS_LAT) * Math.PI - Math.PI / 2;
    const distFromEq   = Math.abs(lat) / (Math.PI / 2);
    const gridTint     = lat > 0 ? '#c8a060' : '#60a0c8';
    if      (distFromEq < 0.05) { ctx.strokeStyle = '#a0dede'; ctx.lineWidth = 2.5; ctx.globalAlpha = 0.9;  }
    else if (distFromEq < 0.4)  { ctx.strokeStyle = gridTint;  ctx.lineWidth = 1.2; ctx.globalAlpha = 0.6; }
    else if (distFromEq < 0.7)  { ctx.strokeStyle = gridTint;  ctx.lineWidth = 0.8; ctx.globalAlpha = 0.4;  }
    else                        { ctx.strokeStyle = gridTint;  ctx.lineWidth = 0.5; ctx.globalAlpha = 0.2;  }
    drawArc(lat, 'lat');
  }
  ctx.globalAlpha = 1;
}

function drawArc(angle, type) {
  const steps = 48; // 48 — good balance of smoothness vs CPU
  let started = false;
  ctx.beginPath();
  for (let i = 0; i <= steps; i++) {
    const t   = i / steps;
    const lon = type === 'lon' ? angle : t * Math.PI * 2;
    const lat = type === 'lon' ? t * Math.PI - Math.PI / 2 : angle;
    const [wx, wy, wz] = spherePoint(lon, lat);
    const [cx, cy, cz] = cameraTransform(wx, wy, wz);
    const proj = project(cx, cy, cz);
    if (proj) {
      if (!started) { ctx.moveTo(proj.sx, proj.sy); started = true; }
      else            ctx.lineTo(proj.sx, proj.sy);
    } else { started = false; }
  }
  ctx.stroke();
}

// ── Grain scheduler — runs on its own interval, independent of render loop ──
// selectedGrainSet is shared with drawParticles for visual highlight only.
let selectedGrainSet = new Set();

// ── Scheduling helpers ────────────────────────────────────────────────────────
function getBufferKey(p) {
  return p.source === 'live' ? `live:${p.liveBufferIdx}` : `sample:${p.sampleIndex}`;
}

function shuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// Keep only particles from top-N most recently used buffers.
function applyRecencyFilter(candidates) {
  if (recencyN <= 0 || candidates.length === 0) return candidates;
  const bufRec = new Map();
  for (const { p } of candidates) {
    const key = getBufferKey(p);
    if ((bufRec.get(key) ?? -Infinity) < p.strokeId) bufRec.set(key, p.strokeId);
  }
  const allowed = new Set(
    [...bufRec.entries()].sort((a, b) => b[1] - a[1]).slice(0, recencyN).map(([k]) => k)
  );
  return candidates.filter(({ p }) => allowed.has(getBufferKey(p)));
}

function findNearestCloudSlot(refLon, refLat) {
  let nearestSlot = -1, nearestAng = Infinity;
  for (let i = 0; i < MAX_CLOUDS; i++) {
    if (!cloudSlots[i]) continue;
    const ang = angleBetweenSphere(cloudSlots[i].lon, cloudSlots[i].lat, refLon, refLat);
    if (ang < nearestAng) { nearestAng = ang; nearestSlot = i; }
  }
  return nearestSlot;
}

let _schedLastAt = 0;
function scheduleGrains() {
  // Measure scheduler drift — how late this tick fired vs 15ms target
  const now = performance.now();
  if (_schedLastAt > 0) perf.schedulerDrift = Math.max(0, (now - _schedLastAt) - 15);
  _schedLastAt = now;

  const { lon: cursorLon, lat: cursorLat } =
    mouseInCanvas ? getMouseLonLat() : getCursorLonLat();
  const k = gp().k;
  const searchRadiusRad = searchRadiusDeg * Math.PI / 180;

  selectedGrainSet = new Set();
  liveGranulatingThisFrame = false;
  perf.grainsFired = 0;

  // ── Cursor grains (only when particles exist) ─────────────────────────────
  if (particles.length) {
    const withAng = particles.map(p => ({
      p,
      ang: angleBetweenSphere(p.lon, p.lat, cursorLon, cursorLat)
    }));

    let toGranulate = [];
    if (nearestMode) {
      withAng.sort((a, b) => a.ang - b.ang);
      if (withAng.length > 0) toGranulate = [withAng[0].p];
    } else {
      const inRadius = withAng.filter(c => c.ang < searchRadiusRad);
      toGranulate = shuffleInPlace(applyRecencyFilter(inRadius)).slice(0, k).map(c => c.p);
    }

    for (const p of toGranulate) {
      selectedGrainSet.add(p);
      playGrain(p);
      perf.grainsFired++;
      if (p.source === 'live') liveGranulatingThisFrame = true;
    }
  }

  // ── Cloud grains — always run, picks up particles painted after drop ──────
  for (let i = 0; i < MAX_CLOUDS; i++) {
    const cloud = cloudSlots[i];
    if (!cloud) continue;
    const cloudRadiusRad = cloud.searchRadiusDeg * Math.PI / 180;
    const cloudCandidates = particles
      .map(p => ({ p, ang: angleBetweenSphere(p.lon, p.lat, cloud.lon, cloud.lat) }))
      .filter(c => c.ang < cloudRadiusRad);
    const cloudGrains = shuffleInPlace(applyRecencyFilter(cloudCandidates)).slice(0, k).map(c => c.p);
    for (const p of cloudGrains) {
      playGrain(p);
      perf.grainsFired++;
      if (p.source === 'live') liveGranulatingThisFrame = true;
      selectedGrainSet.add(p);
    }
  }
}

function drawParticles() {
  const projected = [];

  // ── Build projected draw list ─────────────────────────────────────────────
  // Grain scheduling now happens in scheduleGrains() on its own interval.
  // We just need projection + visual selection from the cached selectedGrainSet.
  const candidates = [];

  for (const p of particles) {
    const [wx, wy, wz] = spherePoint(p.lon, p.lat);
    const [cx, cy, cz] = cameraTransform(wx, wy, wz);
    const proj = project(cx, cy, cz);
    if (!proj) continue;

    const mag    = Math.sqrt(cx*cx + cy*cy + cz*cz);
    const facing = Math.max(0, cz / mag);
    const squash = 0.3 + 0.7 * facing;
    const dx     = proj.sx - canvas.width  / 2;
    const dy     = proj.sy - canvas.height / 2;
    const squashAngle = Math.atan2(dy, dx);

    candidates.push({ p, proj, facing, squash, squashAngle });
  }

  // ── Build projected draw list ─────────────────────────────────────────────
  for (const { p, proj, facing, squash, squashAngle } of candidates) {
    projected.push({ ...proj, color: p.color, selected: selectedGrainSet.has(p), facing, squash, squashAngle });
  }

  projected.sort((a, b) => b.depth - a.depth);

  for (const p of projected) {
    const distFactor = 1 - (p.depth / (SPHERE_RADIUS * 2));
    const size  = PARTICLE_BASE_SIZE + (PARTICLE_MAX_SIZE - PARTICLE_BASE_SIZE) * Math.max(0, distFactor);
    const alpha = (0.3 + 0.7 * Math.max(0, distFactor)) * (0.5 + 0.5 * p.facing);

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.translate(p.sx, p.sy);
    ctx.rotate(p.squashAngle);
    ctx.scale(1, p.squash);

    if (p.selected) {
      ctx.globalAlpha = 1;
      ctx.shadowColor = p.color;
      ctx.shadowBlur  = 25;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth   = 2;
      ctx.beginPath(); ctx.arc(0, 0, size + 5, 0, Math.PI * 2); ctx.stroke();
      ctx.shadowBlur  = 0;
      ctx.globalAlpha = alpha;
    }

    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();

    // White dot = has audio
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath(); ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2); ctx.fill();

    ctx.restore();
  }
}

function angleBetweenSphere(lon1, lat1, lon2, lat2) {
  const x1 = Math.cos(lat1)*Math.cos(lon1), y1 = Math.sin(lat1), z1 = Math.cos(lat1)*Math.sin(lon1);
  const x2 = Math.cos(lat2)*Math.cos(lon2), y2 = Math.sin(lat2), z2 = Math.cos(lat2)*Math.sin(lon2);
  return Math.acos(Math.max(-1, Math.min(1, x1*x2 + y1*y2 + z1*z2)));
}

function drawCursor() {
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const mx = mouseInCanvas ? mousePixelX : cx;
  const my = mouseInCanvas ? mousePixelY : cy;

  const searchRadiusRad = searchRadiusDeg * Math.PI / 180;
  const fovRad   = (FOV_DEG * Math.PI) / 180;
  const focalLen = (canvas.width / 2) / Math.tan(fovRad / 2);
  const brushR   = searchRadiusRad < Math.PI / 2
    ? focalLen * Math.tan(searchRadiusRad)
    : canvas.width * 0.8;

  ctx.save();

  // Centre reference dot
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.beginPath(); ctx.arc(cx, cy, 2.5, 0, Math.PI * 2); ctx.fill();

  if (!mouseInCanvas) { ctx.restore(); return; }

  // Determine painting colour (live-rec overrides sample colour)
  const painting = isPainting;
  const color    = isRecording
    ? LIVE_PAINT_COLORS[liveColorIndex % LIVE_PAINT_COLORS.length]
    : SAMPLE_PAINT_COLORS[activeSampleIndex >= 0 ? activeSampleIndex % SAMPLE_PAINT_COLORS.length : sampleColorIndex];

  if (nearestMode) {
    // Nearest mode: no radius ring — draw a small diamond snap indicator
    const d = 6;
    ctx.strokeStyle = painting ? `${color}cc` : 'rgba(122,188,188,0.5)';
    ctx.lineWidth   = 1.2;
    if (painting) { ctx.shadowColor = color; ctx.shadowBlur = 8; }
    ctx.beginPath();
    ctx.moveTo(mx,     my - d);
    ctx.lineTo(mx + d, my    );
    ctx.lineTo(mx,     my + d);
    ctx.lineTo(mx - d, my    );
    ctx.closePath();
    ctx.stroke();
    ctx.shadowBlur = 0;
  } else if (painting) {
    ctx.fillStyle   = `${color}18`;
    ctx.beginPath(); ctx.arc(mx, my, brushR, 0, Math.PI * 2); ctx.fill();
    ctx.shadowColor = color;
    ctx.shadowBlur  = 12;
    ctx.strokeStyle = `${color}cc`;
    ctx.lineWidth   = 1.5;
    ctx.beginPath(); ctx.arc(mx, my, brushR, 0, Math.PI * 2); ctx.stroke();
    ctx.shadowBlur  = 0;
  } else {
    ctx.strokeStyle = 'rgba(122,188,188,0.35)';
    ctx.lineWidth   = 1;
    ctx.setLineDash([5, 5]);
    ctx.beginPath(); ctx.arc(mx, my, brushR, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([]);
  }

  const tipR = 3, armLen = 7, armGap = tipR + 2;
  ctx.strokeStyle = painting ? 'rgba(255,255,255,0.95)' : 'rgba(255,255,255,0.7)';
  ctx.lineWidth   = 1.5;
  ctx.beginPath(); ctx.arc(mx, my, tipR, 0, Math.PI * 2); ctx.stroke();
  ctx.fillStyle   = painting ? color : 'rgba(255,255,255,0.8)';
  ctx.beginPath(); ctx.arc(mx, my, tipR * 0.45, 0, Math.PI * 2); ctx.fill();

  ctx.strokeStyle = painting ? 'rgba(255,255,255,0.55)' : 'rgba(255,255,255,0.35)';
  ctx.lineWidth   = 1;
  ctx.beginPath();
  ctx.moveTo(mx + armGap, my);   ctx.lineTo(mx + armGap + armLen, my);
  ctx.moveTo(mx - armGap, my);   ctx.lineTo(mx - armGap - armLen, my);
  ctx.moveTo(mx, my - armGap);   ctx.lineTo(mx, my - armGap - armLen);
  ctx.moveTo(mx, my + armGap);   ctx.lineTo(mx, my + armGap + armLen);
  ctx.stroke();

  ctx.restore();
}

// ============================================================================
// EVENTS
// ============================================================================

function setupEvents() {
  canvas.addEventListener('mousemove', e => {
    const rect   = canvas.getBoundingClientRect();
    mouseX       = ((e.clientX - rect.left) / rect.width  - 0.5) * 2;
    mouseY       = ((e.clientY - rect.top)  / rect.height - 0.5) * 2;
    mousePixelX  = (e.clientX - rect.left) * (canvas.width  / rect.width);
    mousePixelY  = (e.clientY - rect.top)  * (canvas.height / rect.height);
    mouseInCanvas = true;
  });
  canvas.addEventListener('mouseleave', () => { mouseInCanvas = false; });

  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect(), t = e.touches[0];
    mouseX = ((t.clientX - rect.left) / rect.width  - 0.5) * 2;
    mouseY = ((t.clientY - rect.top)  / rect.height - 0.5) * 2;
    mouseInCanvas = true;
  });
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect(), t = e.touches[0];
    mouseX = ((t.clientX - rect.left) / rect.width  - 0.5) * 2;
    mouseY = ((t.clientY - rect.top)  / rect.height - 0.5) * 2;
  });
  canvas.addEventListener('touchend', e => { e.preventDefault(); mouseInCanvas = false; });

  // ── Keyboard ────────────────────────────────────────────────────────────────
  document.addEventListener('keydown', async e => {

    // ── Spacebar: live recording + painting ──────────────────────────────────
    if (e.code === 'Space' && !e.repeat) {
      e.preventDefault();
      ensureAudioContext();

      // If mic already enabled via button, go straight to recording — no async delay
      const gotMic = micPermissionGranted ? true : await requestMicAccess();
      if (gotMic) startLiveRecording();

      // Start a new paint stroke for this live recording
      recordStrokeStart('live', currentLiveBufferIdx);
      isPainting      = true;
      paintFrameCount = 0;

      const paint = document.getElementById('paintIndicator');
      paint.textContent = '● rec+paint';
      paint.style.color = LIVE_PAINT_COLORS[liveColorIndex % LIVE_PAINT_COLORS.length];
      paint.classList.add('active');
      updateLiveRecUI();
    }

    // ── Number keys 1–9: momentary sample paint (hold to paint, release to stop) ──
    const num = parseInt(e.key);
    if (num >= 1 && num <= 9 && !e.repeat && !e.metaKey && !e.ctrlKey) {
      const idx = num - 1;
      if (idx < samples.length && samples[idx].buffer) {
        ensureAudioContext();
        activeSampleIndex = idx;
        const s = samples[idx];
        s.grainCursor = s.cropStart * s.duration;

        recordStrokeStart('sample');
        isPainting      = true;
        paintFrameCount = 0;

        const color = SAMPLE_PAINT_COLORS[idx % SAMPLE_PAINT_COLORS.length];
        const paint = document.getElementById('paintIndicator');
        paint.textContent = `paint [${num}]`;
        paint.style.color = color;
        paint.classList.add('active');

        updateSampleListActiveState();
        updateSamplePaintIndicator();
      }
    }

    // ── P: toggle performance monitor ────────────────────────────────────────
    if (e.key === 'p' || e.key === 'P') {
      e.preventDefault();
      perfMonitorVisible = !perfMonitorVisible;
      const el = document.getElementById('perfMonitor');
      if (el) el.style.display = perfMonitorVisible ? 'block' : 'none';
    }

    // ── N: toggle snap/nearest mode ──────────────────────────────────────────
    if (e.key === 'n' || e.key === 'N') {
      e.preventDefault();
      toggleNearestMode();
    }

    // ── [ ] adjust search radius ─────────────────────────────────────────────
    if (e.key === '[' || e.key === ']') {
      e.preventDefault();
      if (e.key === '[') searchRadiusDeg = Math.max(SEARCH_RADIUS_MIN, searchRadiusDeg - SEARCH_RADIUS_STEP);
      if (e.key === ']') searchRadiusDeg = Math.min(SEARCH_RADIUS_MAX, searchRadiusDeg + SEARCH_RADIUS_STEP);
      updatePlaybackControls();
    }

    // ── Cmd/Ctrl+Z: undo last stroke ─────────────────────────────────────────
    if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.repeat) {
      e.preventDefault();
      undoLastStroke();
    }

    // ── ArrowDown: drop cloud at cursor ──────────────────────────────────────
    if (e.key === 'ArrowDown' && !e.repeat) {
      e.preventDefault();
      dropCloud();
    }

    // ── ArrowUp: pick up nearest cloud ───────────────────────────────────────
    if (e.key === 'ArrowUp' && !e.repeat) {
      e.preventDefault();
      pickupNearestCloud();
    }

    // ── M: open MIDI / keyboard map ───────────────────────────────────────────
    if ((e.key === 'm' || e.key === 'M') && !e.metaKey && !e.ctrlKey && !e.repeat) {
      e.preventDefault();
      const modal = document.getElementById('mappingModal');
      if (modal.classList.contains('open')) closeMappingModal();
      else openMappingModal();
    }
  });

  document.addEventListener('keyup', e => {
    // ── Spacebar release: stop recording, end live paint stroke ──────────────
    if (e.code === 'Space') {
      e.preventDefault();
      isPainting      = false;
      currentStrokeId = -1;

      if (isRecording) stopLiveRecording();
      liveColorIndex = (liveColorIndex + 1) % LIVE_PAINT_COLORS.length;

      const paint = document.getElementById('paintIndicator');
      paint.textContent = 'paint: off';
      paint.style.color = '';
      paint.classList.remove('active');

      updateLiveRecUI();
    }

    // ── Number key release: end sample paint stroke ───────────────────────────
    const num = parseInt(e.key);
    if (num >= 1 && num <= 9) {
      const idx = num - 1;
      if (activeSampleIndex === idx) {
        isPainting      = false;
        currentStrokeId = -1;
        activeSampleIndex = -1;

        const paint = document.getElementById('paintIndicator');
        paint.textContent = 'paint: off';
        paint.style.color = '';
        paint.classList.remove('active');

        updateSampleListActiveState();
        updateSamplePaintIndicator();
      }
    }
  });

  window.addEventListener('resize', resizeCanvas);

  // ── Scroll: adjust search radius ────────────────────────────────────────────
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? SEARCH_RADIUS_STEP : -SEARCH_RADIUS_STEP;
    searchRadiusDeg = Math.max(SEARCH_RADIUS_MIN, Math.min(SEARCH_RADIUS_MAX, searchRadiusDeg + delta));
    updatePlaybackControls();
  }, { passive: false });

  // ── Left click: same as spacebar (rec+paint) ─────────────────────────────────
  canvas.addEventListener('mousedown', async e => {
    if (e.button !== 0) return;
    e.preventDefault();
    ensureAudioContext();
    const gotMic = micPermissionGranted ? true : await requestMicAccess();
    if (gotMic) startLiveRecording();
    recordStrokeStart('live', currentLiveBufferIdx);
    isPainting      = true;
    paintFrameCount = 0;
    const paint = document.getElementById('paintIndicator');
    paint.textContent = '● rec+paint';
    paint.style.color = LIVE_PAINT_COLORS[liveColorIndex % LIVE_PAINT_COLORS.length];
    paint.classList.add('active');
    updateLiveRecUI();
  });
  canvas.addEventListener('mouseup', e => {
    if (e.button !== 0) return;
    isPainting      = false;
    currentStrokeId = -1;
    if (isRecording) stopLiveRecording();
    liveColorIndex = (liveColorIndex + 1) % LIVE_PAINT_COLORS.length;
    const paint = document.getElementById('paintIndicator');
    paint.textContent = 'paint: off';
    paint.style.color = '';
    paint.classList.remove('active');
    updateLiveRecUI();
  });

  // ── Right click: undo last stroke ────────────────────────────────────────────
  canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    undoLastStroke();
  });

  canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

  // ── Input gain knob ────────────────────────────────────────────────────────
  // Canvas knob: drag up to increase, drag down to decrease (standard DAW feel)
  // Range: 0–2×, drawn as an arc from ~210° to ~330° (300° sweep, start at bottom-left)
  const knobCanvas  = document.getElementById('inputGainKnob');
  const inputGainValEl = document.getElementById('inputGainVal');
  const KNOB_MIN    = 0;
  const KNOB_MAX    = 2;
  const KNOB_START  = Math.PI * 0.75;          // 135° — bottom-left
  const KNOB_SWEEP  = Math.PI * 1.5;           // 270° total sweep
  const KNOB_PX_PER_UNIT = 80;                 // pixels of drag per full unit (0→1)

  function drawKnob() {
    const kc   = knobCanvas.getContext('2d');
    const W    = knobCanvas.width;
    const H    = knobCanvas.height;
    const cx   = W / 2;
    const cy   = H / 2;
    const r    = W / 2 - 4;
    const t    = (inputGainValue - KNOB_MIN) / (KNOB_MAX - KNOB_MIN); // 0–1
    const endA = KNOB_START + t * KNOB_SWEEP;

    kc.clearRect(0, 0, W, H);

    // Track (full arc, dim)
    kc.beginPath();
    kc.arc(cx, cy, r, KNOB_START, KNOB_START + KNOB_SWEEP);
    kc.strokeStyle = '#2a3a3a';
    kc.lineWidth   = 3;
    kc.lineCap     = 'round';
    kc.stroke();

    // Value arc (teal fill)
    if (t > 0) {
      kc.beginPath();
      kc.arc(cx, cy, r, KNOB_START, endA);
      kc.strokeStyle = inputGainValue > 1.0 ? '#e8a030' : '#7abcbc';
      kc.lineWidth   = 3;
      kc.stroke();
    }

    // Pointer line
    kc.beginPath();
    kc.moveTo(cx, cy);
    kc.lineTo(cx + Math.cos(endA) * (r - 2), cy + Math.sin(endA) * (r - 2));
    kc.strokeStyle = '#ffffff';
    kc.lineWidth   = 1.5;
    kc.stroke();

    // Centre dot
    kc.beginPath();
    kc.arc(cx, cy, 2, 0, Math.PI * 2);
    kc.fillStyle = '#444';
    kc.fill();
  }

  function setInputGain(val) {
    inputGainValue = Math.max(KNOB_MIN, Math.min(KNOB_MAX, val));
    const label = inputGainValue.toFixed(2) + '×';
    inputGainValEl.textContent = label;
    if (inputGainNode) inputGainNode.gain.setTargetAtTime(inputGainValue, ensureAudioContext().currentTime, 0.01);
    drawKnob();
  }

  // Drag interaction — pointer events for both mouse and touch
  let knobDragStart = null;
  knobCanvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    knobCanvas.setPointerCapture(e.pointerId);
    knobDragStart = { y: e.clientY, val: inputGainValue };
  });
  knobCanvas.addEventListener('pointermove', e => {
    if (!knobDragStart) return;
    const dy   = knobDragStart.y - e.clientY; // up = positive
    const delta = dy / KNOB_PX_PER_UNIT;
    setInputGain(knobDragStart.val + delta);
  });
  knobCanvas.addEventListener('pointerup',    () => { knobDragStart = null; });
  knobCanvas.addEventListener('pointercancel',() => { knobDragStart = null; });

  // Double-click to reset to unity
  knobCanvas.addEventListener('dblclick', () => setInputGain(1.0));

  // Draw initial state
  drawKnob();

  // Fullscreen
  document.getElementById('fullscreenBtn').addEventListener('click', () => {
    const wrapper = document.getElementById('canvasWrapper');
    if (!document.fullscreenElement) wrapper.requestFullscreen().catch(() => {});
    else document.exitFullscreen();
  });
  document.addEventListener('fullscreenchange', () => {
    document.getElementById('fullscreenBtn').textContent =
      document.fullscreenElement ? '✕' : '⛶';
    resizeCanvas();
  });
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================

let _animLastAt = 0;
function animate() {
  const _animNow = performance.now();
  if (_animLastAt > 0) perf.frameMs = _animNow - _animLastAt;
  _animLastAt = _animNow;
  perfTick();

  // ── Camera rotation ──────────────────────────────────────────────────────
  if (mouseInCanvas) {
    const dist = Math.sqrt(mouseX*mouseX + mouseY*mouseY);
    const DEAD_ZONE = 0.30;
    if (dist > DEAD_ZONE) {
      const t     = Math.min((dist - DEAD_ZONE) / (1 - DEAD_ZONE), 1);
      const curve = t * t * t * t;
      const speed = curve * ROTATION_SPEED;
      const nx = mouseX / dist, ny = mouseY / dist;

      if (Math.abs(nx) > 0.001) {
        const camUp  = qRotateVec(camQ, [0, 1, 0]);
        const yawSign = camUp[1] < 0 ? -1 : 1;
        const qYaw   = qFromAxisAngle(0, 1, 0, nx * speed * yawSign);
        camQ = qNormalize(qMul(qYaw, camQ));
      }
      if (Math.abs(ny) > 0.001) {
        const qPitch = qFromAxisAngle(1, 0, 0, ny * speed);
        camQ = qNormalize(qMul(camQ, qPitch));
      }
    }
  } else {
    const qAuto = qFromAxisAngle(0, 1, 0, AUTO_ROTATION_SPEED);
    camQ = qNormalize(qMul(qAuto, camQ));
  }

  // ── Drop particles while painting ────────────────────────────────────────
  if (isPainting) {
    paintFrameCount++;
    if (paintFrameCount % PAINT_INTERVAL === 0) {
      const { lon, lat } = getMouseLonLat();
      const gpr = gp();
      const durVariation = rand(-gpr.durJitter * 0.5, gpr.durJitter * 0.5);

      let particle = null;

      if (isRecording && currentLiveBufferIdx >= 0) {
        // ── Live rec particle ──────────────────────────────────────────────
        const recTime = getRecordingDuration();
        particle = {
          lon, lat,
          strokeId:      currentStrokeId,
          lastTriggeredAt: undefined,
          grainDuration: Math.max(0.05, gpr.duration + durVariation),
          source:        'live',
          liveBufferIdx: currentLiveBufferIdx,
          // Place grain so it reads backward from recTime, but never before 0.
          // If the buffer isn't long enough yet, start at 0 — playGrain will
          // push startPos forward to fit the full grain rather than truncating.
          grainStart:    Math.max(0, recTime - gpr.duration),
          color:         LIVE_PAINT_COLORS[liveColorIndex % LIVE_PAINT_COLORS.length]
        };
      } else if (activeSampleIndex >= 0 && samples[activeSampleIndex] && samples[activeSampleIndex].buffer) {
        // ── Loaded-sample particle ─────────────────────────────────────────
        const s          = samples[activeSampleIndex];
        const cropStart  = s.cropStart * s.duration;
        const cropEnd    = s.cropEnd   * s.duration;
        const cropLen    = cropEnd - cropStart;
        const startJitter = rand(-gpr.startJitter * 0.3, gpr.startJitter * 0.3);
        let rawStart      = s.grainCursor + startJitter;
        if (cropLen > 0) rawStart = cropStart + ((rawStart - cropStart) % cropLen + cropLen) % cropLen;
        const clampedStart = Math.max(cropStart, Math.min(rawStart, cropEnd - 0.01));
        const grainDur     = Math.max(0.05, Math.min(gpr.duration + durVariation, cropEnd - clampedStart));

        particle = {
          lon, lat,
          strokeId:      currentStrokeId,
          lastTriggeredAt: undefined,
          source:        'sample',
          sampleIndex:   activeSampleIndex,
          grainStart:    clampedStart,
          grainDuration: grainDur,
          color:         SAMPLE_PAINT_COLORS[activeSampleIndex % SAMPLE_PAINT_COLORS.length]
        };

        const stride = (gpr.duration - gpr.overlap) * rand(0.8, 1.2);
        s.grainCursor += stride;
        if (s.grainCursor > cropEnd) s.grainCursor = cropStart + ((s.grainCursor - cropStart) % cropLen);
      }
      // else: no audio source active — don't emit a particle

      if (particle) particles.push(particle);
    }
  }

  // ── Rebuild live buffer every frame during recording ─────────────────────
  if (isRecording) rebuildLiveBuffer();

  // ── Cap render loop at 30fps to halve canvas/JS CPU load ─────────────────
  // Grain scheduling (audio thread) is unaffected — it runs independently.
  const now30 = performance.now();
  const elapsed30 = now30 - (animate._lastRenderTime || 0);
  if (elapsed30 >= 33) { // 1000/30 ≈ 33ms
    animate._lastRenderTime = now30 - (elapsed30 % 33);
    drawFrame();
    updateWaveformPlayheads();

    const { lon, lat } = mouseInCanvas ? getMouseLonLat() : getCursorLonLat();
    document.getElementById('coordinates').textContent =
      `${(lon * 180 / Math.PI).toFixed(1)},${(lat * 180 / Math.PI).toFixed(1)}`;
  }

  requestAnimationFrame(animate);
}

// ============================================================================
// MIDI + KEYBOARD MAPPING SYSTEM
// ============================================================================

// Each action definition: { id, label, key (display string), fn, type }
// type: 'trigger' (fire once) | 'cc' (continuous 0-127 → value)
const ACTIONS = [
  { id: 'recpaint',    label: 'rec + paint (hold)',  key: 'click / space', type: 'trigger' },
  { id: 'undo',        label: 'undo last stroke',     key: 'right click / ⌘Z', type: 'trigger' },
  { id: 'drop_cloud',  label: 'drop cloud',           key: '↓', type: 'trigger' },
  { id: 'pickup_cloud',label: 'pick up cloud',        key: '↑', type: 'trigger' },
  { id: 'snap',        label: 'toggle snap/nearest',  key: 'N', type: 'trigger' },
  { id: 'perf',        label: 'toggle perf monitor',  key: 'P', type: 'trigger' },
  { id: 'paint1',      label: 'paint sample 1',       key: '1', type: 'trigger' },
  { id: 'paint2',      label: 'paint sample 2',       key: '2', type: 'trigger' },
  { id: 'paint3',      label: 'paint sample 3',       key: '3', type: 'trigger' },
  { id: 'paint4',      label: 'paint sample 4',       key: '4', type: 'trigger' },
  { id: 'paint5',      label: 'paint sample 5',       key: '5', type: 'trigger' },
  { id: 'paint6',      label: 'paint sample 6',       key: '6', type: 'trigger' },
  { id: 'paint7',      label: 'paint sample 7',       key: '7', type: 'trigger' },
  { id: 'paint8',      label: 'paint sample 8',       key: '8', type: 'trigger' },
  { id: 'paint9',      label: 'paint sample 9',       key: '9', type: 'trigger' },
  { id: 'radius_dec',  label: 'radius decrease',      key: 'scroll down / [', type: 'trigger' },
  { id: 'radius_inc',  label: 'radius increase',      key: 'scroll up / ]', type: 'trigger' },
  { id: 'radius_cc',   label: 'radius (continuous)',  key: '—', type: 'cc',
    ccFn: v => { searchRadiusDeg = SEARCH_RADIUS_MIN + (v / 127) * (SEARCH_RADIUS_MAX - SEARCH_RADIUS_MIN); updatePlaybackControls(); } },
  { id: 'recency_cc',  label: 'recency N (continuous)', key: '—', type: 'cc',
    ccFn: v => { recencyN = 1 + Math.round((v / 127) * 15); document.getElementById('recencyVal').textContent = recencyN; } },
  { id: 'preset_cc',   label: 'preset select (CC)',   key: '—', type: 'cc',
    ccFn: v => { const idx = Math.min(PRESETS.length - 1, Math.floor((v / 127) * PRESETS.length)); selectPreset(idx); } },
  { id: 'mapping',     label: 'open midi map',        key: 'M', type: 'trigger' },
];

// MIDI mappings: { actionId → { type: 'cc'|'note', channel, number } }
let midiMappings = {};
let midiLearningId = null;   // which action is currently in learn mode
let midiAccess = null;

function loadMidiMappings() {
  try {
    const saved = localStorage.getItem('mubone_midi_map');
    if (saved) midiMappings = JSON.parse(saved);
  } catch(e) { midiMappings = {}; }
}

function saveMidiMappings() {
  try { localStorage.setItem('mubone_midi_map', JSON.stringify(midiMappings)); } catch(e) {}
}

async function initMidi() {
  if (!navigator.requestMIDIAccess) return;
  try {
    midiAccess = await navigator.requestMIDIAccess({ sysex: false });
    refreshMidiInputs();
    midiAccess.onstatechange = refreshMidiInputs;
  } catch(e) {
    console.log('MIDI not available:', e.message);
  }
}

function refreshMidiInputs() {
  const inputs = [...midiAccess.inputs.values()];
  const portEl = document.getElementById('midiPortName');
  if (portEl) portEl.textContent = inputs.length ? inputs.map(i => i.name).join(', ') : '—';
  for (const input of inputs) {
    input.onmidimessage = handleMidiMessage;
  }
}

function handleMidiMessage(event) {
  const [status, num, val] = event.data;
  const type   = status >> 4;     // 8=note off, 9=note on, 11=CC
  const channel = (status & 0xF) + 1;

  if (midiLearningId !== null) {
    // Assign this MIDI message to the learning action
    const mapType = (type === 11) ? 'cc' : 'note';
    midiMappings[midiLearningId] = { type: mapType, channel, number: num };
    saveMidiMappings();
    const action = ACTIONS.find(a => a.id === midiLearningId);
    setMappingStatus(`mapped "${action?.label}" → ${mapType.toUpperCase()} ${num} ch${channel}`);
    midiLearningId = null;
    renderMappingTable();
    return;
  }

  // Dispatch to mapped actions
  for (const action of ACTIONS) {
    const mapping = midiMappings[action.id];
    if (!mapping) continue;
    const matchCC   = mapping.type === 'cc'   && type === 11 && mapping.number === num && mapping.channel === channel;
    const matchNote = mapping.type === 'note' && type === 9  && mapping.number === num && mapping.channel === channel && val > 0;
    if (matchCC || matchNote) {
      dispatchAction(action.id, matchCC ? val : 127);
    }
  }
}

function dispatchAction(id, midiVal) {
  switch(id) {
    case 'recpaint':    if (!isPainting) { ensureAudioContext(); startLiveRecording(); recordStrokeStart('live', currentLiveBufferIdx); isPainting = true; paintFrameCount = 0; } break;
    case 'undo':        undoLastStroke(); break;
    case 'drop_cloud':  dropCloud(); break;
    case 'pickup_cloud':pickupNearestCloud(); break;
    case 'snap':        toggleNearestMode(); break;
    case 'perf':        perfMonitorVisible = !perfMonitorVisible; { const el = document.getElementById('perfMonitor'); if (el) el.style.display = perfMonitorVisible ? 'block' : 'none'; } break;
    case 'radius_dec':  searchRadiusDeg = Math.max(SEARCH_RADIUS_MIN, searchRadiusDeg - SEARCH_RADIUS_STEP); updatePlaybackControls(); break;
    case 'radius_inc':  searchRadiusDeg = Math.min(SEARCH_RADIUS_MAX, searchRadiusDeg + SEARCH_RADIUS_STEP); updatePlaybackControls(); break;
    case 'mapping':     openMappingModal(); break;
    default:
      if (id.startsWith('paint')) {
        const n = parseInt(id.replace('paint', ''));
        const idx = n - 1;
        if (idx < samples.length && samples[idx].buffer) {
          ensureAudioContext(); activeSampleIndex = idx;
          const s = samples[idx]; s.grainCursor = s.cropStart * s.duration;
          recordStrokeStart('sample'); isPainting = true; paintFrameCount = 0;
        }
      }
      // CC actions handled via ccFn directly
      const action = ACTIONS.find(a => a.id === id);
      if (action?.type === 'cc' && action.ccFn) action.ccFn(midiVal);
      break;
  }
}

// ── Modal UI ─────────────────────────────────────────────────────────────────
function openMappingModal() {
  renderMappingTable();
  document.getElementById('mappingModal').classList.add('open');
}

function closeMappingModal() {
  midiLearningId = null;
  document.getElementById('mappingModal').classList.remove('open');
  setMappingStatus('');
  renderMappingTable();
}

function setMappingStatus(msg) {
  const el = document.getElementById('mappingStatus');
  if (el) el.textContent = msg;
}

function renderMappingTable() {
  const tbody = document.getElementById('mappingTableBody');
  if (!tbody) return;
  tbody.innerHTML = '';

  for (const action of ACTIONS) {
    const mapping = midiMappings[action.id];
    const isLearning = midiLearningId === action.id;

    const tr = document.createElement('tr');

    // Function name
    const tdName = document.createElement('td');
    tdName.className = 'fn-name';
    tdName.textContent = action.label;
    tr.appendChild(tdName);

    // Keyboard shortcut
    const tdKey = document.createElement('td');
    if (action.key && action.key !== '—') {
      const badge = document.createElement('span');
      badge.className = 'key-badge';
      badge.textContent = action.key;
      tdKey.appendChild(badge);
    } else {
      tdKey.textContent = '—';
      tdKey.style.color = '#444';
    }
    tr.appendChild(tdKey);

    // MIDI assignment
    const tdMidi = document.createElement('td');
    tdMidi.className = 'midi-cell' + (mapping ? '' : ' unassigned');
    if (mapping) {
      tdMidi.textContent = `${mapping.type.toUpperCase()} ${mapping.number} ch${mapping.channel}`;
    } else {
      tdMidi.textContent = 'unassigned';
    }
    tr.appendChild(tdMidi);

    // Learn + clear buttons
    const tdBtn = document.createElement('td');
    tdBtn.style.whiteSpace = 'nowrap';

    const learnBtn = document.createElement('button');
    learnBtn.className = 'learn-btn' + (isLearning ? ' learning' : '');
    learnBtn.textContent = isLearning ? 'waiting…' : 'learn';
    learnBtn.addEventListener('click', () => {
      if (midiLearningId === action.id) {
        midiLearningId = null;
        setMappingStatus('');
      } else {
        midiLearningId = action.id;
        setMappingStatus(`move a midi control to assign "${action.label}"…`);
        if (!midiAccess) initMidi().then(refreshMidiInputs);
      }
      renderMappingTable();
    });
    tdBtn.appendChild(learnBtn);

    if (mapping) {
      const clearBtn = document.createElement('button');
      clearBtn.className = 'clear-midi-btn';
      clearBtn.textContent = '✕';
      clearBtn.title = 'clear midi assignment';
      clearBtn.addEventListener('click', () => {
        delete midiMappings[action.id];
        saveMidiMappings();
        renderMappingTable();
      });
      tdBtn.appendChild(clearBtn);
    }
    tr.appendChild(tdBtn);

    tbody.appendChild(tr);
  }
}

// ── Modal open/close wiring (done after DOM ready, called from init) ──────────
function setupMappingModal() {
  loadMidiMappings();
  document.getElementById('mappingClose')?.addEventListener('click', closeMappingModal);
  document.getElementById('mappingModal')?.addEventListener('click', e => {
    if (e.target === document.getElementById('mappingModal')) closeMappingModal();
  });
  document.getElementById('clearAllMidi')?.addEventListener('click', () => {
    midiMappings = {};
    saveMidiMappings();
    renderMappingTable();
    setMappingStatus('all midi mappings cleared');
  });
}

// ============================================================================
// START
// ============================================================================

init();
</script>
</body>
</html>
