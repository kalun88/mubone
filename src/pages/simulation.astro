---
import Base from "@/layouts/Base.astro";

const title = "mubone — simulation";
const description = "Interactive browser-based mubone sound composition with a 3D dotted sphere, drag-to-rotate control, and touch-based sound painting.";
---

<Base title={title} description={description}>
  <div class="simulation-container">
    <div class="simulation-header">
      <h1 class="simulation-title">simulation</h1>
    </div>

    <div class="canvas-wrapper">
      <canvas id="sphereCanvas"></canvas>
      <div id="hud" class="hud">
        <div id="coordinates" class="hud-text">--,--</div>
        <div id="soundNumber" class="hud-text">-</div>
      </div>
    </div>

    <div class="numberpad">
      {[1, 2, 3, 4, 5, 6, 7, 8, 9].map((num) => (
        <button
          class={`numberpad-btn btn-${num}`}
          data-sound={num}
        >
          {num}
        </button>
      ))}
    </div>

    <div class="instructions">
      drag to rotate · tap to paint · 1-9 select sound
    </div>
  </div>
</Base>

<style>
  .simulation-container {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
  }

  .simulation-header {
    border-bottom: 1px solid var(--color-rule);
    padding-bottom: 1rem;
  }

  .simulation-title {
    font-size: 1rem;
    font-weight: normal;
    color: var(--color-text-muted);
    margin: 0;
    font-family: "Roboto Mono", monospace;
    letter-spacing: 0.05em;
  }

  .canvas-wrapper {
    position: relative;
    width: 100%;
    background: var(--color-bg-surface);
    border: 1px solid var(--color-rule);
    aspect-ratio: 4 / 3;
    border-radius: 4px;
    overflow: hidden;
  }

  #sphereCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .hud {
    position: absolute;
    top: 1rem;
    left: 1rem;
    display: flex;
    gap: 2rem;
    font-family: "Roboto Mono", monospace;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    pointer-events: none;
  }

  .hud-text {
    min-width: 60px;
  }

  .numberpad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
    max-width: 300px;
    margin: 0 auto;
  }

  .numberpad-btn {
    padding: 0.75rem;
    font-size: 1rem;
    font-family: "Roboto Mono", monospace;
    font-weight: bold;
    background: var(--color-bg-surface);
    color: var(--color-text);
    border: 1px solid var(--color-rule);
    border-left: 3px solid;
    cursor: pointer;
    transition: all 0.1s ease;
    border-radius: 2px;
  }

  .numberpad-btn:hover {
    background: var(--color-rule);
  }

  .numberpad-btn:active {
    transform: scale(0.95);
  }

  /* Color-coded left borders for each sound */
  .btn-1 { border-left-color: #ff6b6b; }
  .btn-2 { border-left-color: #ffa06b; }
  .btn-3 { border-left-color: #ffd06b; }
  .btn-4 { border-left-color: #a0ff6b; }
  .btn-5 { border-left-color: #6bffa0; }
  .btn-6 { border-left-color: #6bffd0; }
  .btn-7 { border-left-color: #6ba0ff; }
  .btn-8 { border-left-color: #6b6bff; }
  .btn-9 { border-left-color: #d06bff; }

  .instructions {
    text-align: center;
    font-family: "Roboto Mono", monospace;
    font-size: 0.75rem;
    color: var(--color-text-dim);
    letter-spacing: 0.05em;
  }

  @media (max-width: 640px) {
    .simulation-container {
      padding: 1rem;
      gap: 1rem;
    }

    .canvas-wrapper {
      aspect-ratio: 3 / 4;
    }

    .hud {
      font-size: 0.65rem;
      gap: 1rem;
    }

    .instructions {
      font-size: 0.65rem;
    }
  }
</style>

<script>
  // ============================================================================
  // CONSTANTS & CONFIGURATION
  // ============================================================================

  const SPHERE_SEGMENTS = 24; // longitude segments
  const SPHERE_RINGS = 12;    // latitude rings
  const DOT_BASE_RADIUS = 2;
  const FOV = 500;
  const AUTO_ROTATION_SPEED = 0.0003; // radians per frame
  const MOMENTUM_DECAY = 0.95;
  const DRAG_SENSITIVITY = 0.005;
  const TAP_THRESHOLD = 10; // pixels

  // Sound frequencies (Hz)
  const SOUND_FREQS = [
    { freq: 130, waveform: 'sine' },     // 1: C3
    { freq: 196, waveform: 'sine' },     // 2: G3
    { freq: 262, waveform: 'sine' },     // 3: C4
    { freq: 330, waveform: 'triangle' }, // 4: E4
    { freq: 392, waveform: 'triangle' }, // 5: G4
    { freq: 523, waveform: 'triangle' }, // 6: C5
    { freq: 220, waveform: 'sawtooth' }, // 7: 220Hz sawtooth
    { freq: 330, waveform: 'sawtooth' }, // 8: 330Hz sawtooth
    { freq: 440, waveform: 'sawtooth' }  // 9: 440Hz sawtooth (A4)
  ];

  const SOUND_COLORS = [
    '#ff6b6b', // 1: red
    '#ffa06b', // 2: orange-red
    '#ffd06b', // 3: orange
    '#a0ff6b', // 4: yellow-green
    '#6bffa0', // 5: green
    '#6bffd0', // 6: cyan
    '#6ba0ff', // 7: blue
    '#6b6bff', // 8: purple
    '#d06bff'  // 9: magenta
  ];

  // ============================================================================
  // TYPES
  // ============================================================================

  interface Dot3D {
    lon: number;
    lat: number;
    x: number;
    y: number;
    z: number;
  }

  interface PaintedDot {
    lon: number;
    lat: number;
    soundIndex: number;
    color: string;
  }

  interface Particle {
    x: number;
    y: number;
    z: number;
    lon: number;
    lat: number;
  }

  // ============================================================================
  // STATE
  // ============================================================================

  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let audioContext: AudioContext | null = null;
  let currentSoundIndex = 0; // 0-8 (displays as 1-9)

  let rotX = 0;
  let rotY = 0;
  let rotXVelocity = 0;
  let rotYVelocity = 0;

  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let lastMouseX = 0;
  let lastMouseY = 0;

  let dots: Dot3D[] = [];
  let paintedDots: PaintedDot[] = [];
  let triggeredDots = new Set<number>();
  let playheadLon = 0;
  let lastPlayheadPos = 0;

  let animationFrameId: number;

  // ============================================================================
  // INITIALIZATION
  // ============================================================================

  function init() {
    canvas = document.getElementById('sphereCanvas') as HTMLCanvasElement;
    ctx = canvas.getContext('2d')!;

    resizeCanvas();
    generateSphereDots();
    setupEventListeners();
    animate();
  }

  function resizeCanvas() {
    const rect = canvas.parentElement!.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }

  function generateSphereDots() {
    dots = [];
    for (let ring = 0; ring < SPHERE_RINGS; ring++) {
      const lat = (Math.PI / SPHERE_RINGS) * (ring + 0.5) - Math.PI / 2;
      for (let seg = 0; seg < SPHERE_SEGMENTS; seg++) {
        const lon = (Math.PI * 2 / SPHERE_SEGMENTS) * seg;
        dots.push({
          lon,
          lat,
          x: 0,
          y: 0,
          z: 0
        });
      }
    }
  }

  // ============================================================================
  // 3D MATH
  // ============================================================================

  function sphericalToCartesian(lon: number, lat: number, radius: number = 100) {
    return {
      x: radius * Math.cos(lat) * Math.cos(lon),
      y: radius * Math.sin(lat),
      z: radius * Math.cos(lat) * Math.sin(lon)
    };
  }

  function cartesianToSpherical(x: number, y: number, z: number) {
    const radius = Math.sqrt(x * x + y * y + z * z);
    const lat = Math.asin(y / radius);
    const lon = Math.atan2(z, x);
    return { lon, lat, radius };
  }

  function applyRotationX(p: { x: number; y: number; z: number }, angle: number) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
      x: p.x,
      y: p.y * cos - p.z * sin,
      z: p.y * sin + p.z * cos
    };
  }

  function applyRotationY(p: { x: number; y: number; z: number }, angle: number) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return {
      x: p.x * cos + p.z * sin,
      y: p.y,
      z: -p.x * sin + p.z * cos
    };
  }

  function projectTo2D(p: { x: number; y: number; z: number }, centerX: number, centerY: number) {
    const scale = FOV / (FOV + p.z);
    return {
      x: centerX + p.x * scale,
      y: centerY - p.y * scale,
      scale,
      z: p.z
    };
  }

  // ============================================================================
  // RENDERING
  // ============================================================================

  function drawFrame() {
    // Clear canvas
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-bg-surface').trim();
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // Transform and project all dots
    const projectedDots = dots.map(dot => {
      let p = sphericalToCartesian(dot.lon, dot.lat, 100);
      p = applyRotationX(p, rotX);
      p = applyRotationY(p, rotY);
      dot.x = p.x;
      dot.y = p.y;
      dot.z = p.z;

      const proj = projectTo2D(p, centerX, centerY);
      return { ...proj, lon: dot.lon, lat: dot.lat, index: dots.indexOf(dot) };
    });

    // Transform and project painted dots
    const projectedPainted = paintedDots.map(pd => {
      let p = sphericalToCartesian(pd.lon, pd.lat, 100);
      p = applyRotationX(p, rotX);
      p = applyRotationY(p, rotY);

      const proj = projectTo2D(p, centerX, centerY);
      return { ...proj, color: pd.color, soundIndex: pd.soundIndex };
    });

    // Draw playhead (vertical arc at current playhead longitude)
    drawPlayhead(centerX, centerY);

    // Draw grid dots (background)
    projectedDots.forEach(dot => {
      if (dot.z > -100) { // Only draw front-facing dots
        const brightness = Math.max(0, (1 + dot.z / 200)); // depth-based brightness
        const alpha = Math.max(0.1, brightness);
        const radius = DOT_BASE_RADIUS * dot.scale;

        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    // Draw painted dots (foreground)
    projectedPainted.forEach(pd => {
      if (pd.z > -100) {
        const brightness = Math.max(0, (1 + pd.z / 200));
        const alpha = Math.max(0.2, brightness);
        const radius = DOT_BASE_RADIUS * pd.scale * 1.5;

        ctx.fillStyle = pd.color;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(pd.x, pd.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    });
  }

  function drawPlayhead(centerX: number, centerY: number) {
    // Draw a vertical line on the sphere at playhead longitude
    const steps = 20;
    const segments = [];

    for (let i = 0; i <= steps; i++) {
      const lat = (i / steps) * Math.PI - Math.PI / 2;
      let p = sphericalToCartesian(playheadLon, lat, 100);
      p = applyRotationX(p, rotX);
      p = applyRotationY(p, rotY);

      const proj = projectTo2D(p, centerX, centerY);
      if (proj.z > -100) {
        segments.push(proj);
      }
    }

    // Draw playhead line
    if (segments.length > 1) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(segments[0].x, segments[0].y);
      for (let i = 1; i < segments.length; i++) {
        ctx.lineTo(segments[i].x, segments[i].y);
      }
      ctx.stroke();
    }
  }

  // ============================================================================
  // INTERACTION
  // ============================================================================

  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    }
  }

  function playSound(soundIndex: number) {
    initAudioContext();
    if (!audioContext) return;

    const { freq, waveform } = SOUND_FREQS[soundIndex];
    const now = audioContext.currentTime;
    const duration = 0.21; // 10ms attack + 200ms decay

    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = waveform as OscillatorType;
    osc.frequency.value = freq;

    // Attack and decay envelope
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(1, now + 0.01); // 10ms attack
    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

    // For sawtooth, add a lowpass filter
    if (waveform === 'sawtooth') {
      const filter = audioContext.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1000;
      osc.connect(filter);
      filter.connect(gain);
    } else {
      osc.connect(gain);
    }

    gain.connect(audioContext.destination);
    osc.start(now);
    osc.stop(now + duration);
  }

  function screenToSphere(screenX: number, screenY: number): { lon: number; lat: number } | null {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const relX = screenX - centerX;
    const relY = centerY - screenY;

    const distFromCenter = Math.sqrt(relX * relX + relY * relY);
    const radius = Math.min(canvas.width, canvas.height) * 0.35; // ~60-70% fill

    if (distFromCenter > radius) {
      return null; // Outside sphere
    }

    // Estimate 3D position on sphere surface
    const lat = Math.asin(Math.max(-1, Math.min(1, relY / radius)));
    const lon = Math.atan2(relX, radius * Math.cos(lat));

    return { lon, lat };
  }

  function updateHUD(lon: number | null, lat: number | null) {
    const coordDiv = document.getElementById('coordinates');
    const soundDiv = document.getElementById('soundNumber');

    if (lon !== null && lat !== null) {
      const lonDeg = (lon * 180 / Math.PI).toFixed(1);
      const latDeg = (lat * 180 / Math.PI).toFixed(1);
      coordDiv!.textContent = `${lonDeg},${latDeg}`;
    } else {
      coordDiv!.textContent = '--,--';
    }

    soundDiv!.textContent = String(currentSoundIndex + 1);
  }

  // ============================================================================
  // EVENT HANDLERS
  // ============================================================================

  function setupEventListeners() {
    // Mouse events
    canvas.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mousemove', handleMouseMoveHUD);

    // Touch events
    canvas.addEventListener('touchstart', handleTouchStart);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);

    // Keyboard
    document.addEventListener('keydown', handleKeyDown);

    // Number pad buttons
    document.querySelectorAll('.numberpad-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const soundIndex = parseInt((e.target as HTMLButtonElement).dataset.sound!) - 1;
        selectSound(soundIndex);
      });
    });

    // Window resize
    window.addEventListener('resize', resizeCanvas);
  }

  function handleMouseDown(e: MouseEvent) {
    initAudioContext();
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }

  function handleMouseMove(e: MouseEvent) {
    if (!isDragging) return;

    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;

    rotYVelocity = dx * DRAG_SENSITIVITY;
    rotXVelocity = dy * DRAG_SENSITIVITY;

    rotY += rotYVelocity;
    rotX += rotXVelocity;

    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }

  function handleMouseUp(e: MouseEvent) {
    if (!isDragging) return;

    const totalDrag = Math.sqrt(
      Math.pow(e.clientX - dragStartX, 2) +
      Math.pow(e.clientY - dragStartY, 2)
    );

    // If tap (very small drag), paint a dot
    if (totalDrag < TAP_THRESHOLD) {
      const spherePos = screenToSphere(e.clientX, e.clientY);
      if (spherePos) {
        paintDot(spherePos.lon, spherePos.lat, currentSoundIndex);
        playSound(currentSoundIndex);
      }
    }

    isDragging = false;
    // Momentum continues via rotXVelocity and rotYVelocity
  }

  function handleMouseMoveHUD(e: MouseEvent) {
    if (isDragging) return;

    const spherePos = screenToSphere(e.clientX, e.clientY);
    if (spherePos) {
      updateHUD(spherePos.lon, spherePos.lat);
    } else {
      updateHUD(null, null);
    }
  }

  function handleTouchStart(e: TouchEvent) {
    initAudioContext();
    isDragging = true;
    dragStartX = e.touches[0].clientX;
    dragStartY = e.touches[0].clientY;
    lastMouseX = dragStartX;
    lastMouseY = dragStartY;
  }

  function handleTouchMove(e: TouchEvent) {
    if (!isDragging) return;

    const dx = e.touches[0].clientX - lastMouseX;
    const dy = e.touches[0].clientY - lastMouseY;

    rotYVelocity = dx * DRAG_SENSITIVITY;
    rotXVelocity = dy * DRAG_SENSITIVITY;

    rotY += rotYVelocity;
    rotX += rotXVelocity;

    lastMouseX = e.touches[0].clientX;
    lastMouseY = e.touches[0].clientY;
  }

  function handleTouchEnd(e: TouchEvent) {
    if (!isDragging) return;

    const totalDrag = Math.sqrt(
      Math.pow(e.changedTouches[0].clientX - dragStartX, 2) +
      Math.pow(e.changedTouches[0].clientY - dragStartY, 2)
    );

    if (totalDrag < TAP_THRESHOLD) {
      const spherePos = screenToSphere(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
      if (spherePos) {
        paintDot(spherePos.lon, spherePos.lat, currentSoundIndex);
        playSound(currentSoundIndex);
      }
    }

    isDragging = false;
  }

  function handleKeyDown(e: KeyboardEvent) {
    const num = parseInt(e.key);
    if (num >= 1 && num <= 9) {
      initAudioContext();
      const soundIndex = num - 1;
      selectSound(soundIndex);
    }
  }

  function selectSound(soundIndex: number) {
    currentSoundIndex = soundIndex;
    playSound(soundIndex);
    updateHUD(null, null); // Force HUD update
  }

  function paintDot(lon: number, lat: number, soundIndex: number) {
    paintedDots.push({
      lon,
      lat,
      soundIndex,
      color: SOUND_COLORS[soundIndex]
    });
  }

  // ============================================================================
  // PLAYHEAD & TRIGGERING
  // ============================================================================

  function checkAndTriggerDots() {
    // Advance playhead with auto-rotation
    playheadLon += AUTO_ROTATION_SPEED;
    if (playheadLon > Math.PI * 2) {
      playheadLon -= Math.PI * 2;
    }

    // Check if any painted dots cross the playhead
    paintedDots.forEach((pd, idx) => {
      const normalizedLon = pd.lon % (Math.PI * 2);
      const normalizedPlayhead = playheadLon % (Math.PI * 2);

      // Detect crossing
      let crossedPlayhead = false;
      if (lastPlayheadPos < normalizedPlayhead) {
        // Normal case: playhead moved forward
        if (normalizedLon > lastPlayheadPos && normalizedLon <= normalizedPlayhead) {
          crossedPlayhead = true;
        }
      } else {
        // Wrapped around
        if (normalizedLon > lastPlayheadPos || normalizedLon <= normalizedPlayhead) {
          crossedPlayhead = true;
        }
      }

      if (crossedPlayhead && !triggeredDots.has(idx)) {
        triggeredDots.add(idx);
        playSound(pd.soundIndex);
      }
    });

    lastPlayheadPos = playheadLon % (Math.PI * 2);

    // Reset triggered dots when playhead completes a full rotation
    if (playheadLon > Math.PI * 2) {
      triggeredDots.clear();
      playheadLon -= Math.PI * 2;
      lastPlayheadPos = 0;
    }
  }

  // ============================================================================
  // ANIMATION LOOP
  // ============================================================================

  function animate() {
    // Update rotation with momentum and decay
    if (!isDragging) {
      rotY += rotYVelocity;
      rotX += rotXVelocity;
      rotYVelocity *= MOMENTUM_DECAY;
      rotXVelocity *= MOMENTUM_DECAY;

      // Auto-rotation
      if (!isDragging) {
        rotY += AUTO_ROTATION_SPEED;
      }
    }

    // Check for playhead triggers
    checkAndTriggerDots();

    // Render
    drawFrame();

    animationFrameId = requestAnimationFrame(animate);
  }

  // ============================================================================
  // STARTUP
  // ============================================================================

  init();
</script>
